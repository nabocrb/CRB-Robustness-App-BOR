---
title: "CRB robustness tradeoffs"
output: 
  flexdashboard::flex_dashboard:
    source_code: "https://github.com/nabocrb/CRB-Robustness-App-BOR"
    
runtime: shiny
---

```{r, setup, include=FALSE}

######################## load packages and user defined functions #############
source("Function library.R", local=TRUE) # must include local=TRUE. See here: https://shiny.rstudio.com/articles/scoping.html

function_df=reactiveValues() # need to initialize the dataframes used in the manual and brush filter functions
manual_log=reactiveValues()  # initialize the log

######################## import robustness metrics data ############################

# this includes the non dominated front. Calculated externally to save app loading time
metrics_4app_n500=readRDS('tradeoff_dataframes.rds')
metrics_4app_n300=readRDS("tradeoff_dataframes_300SOW.rds")

# used for x axis in stacked histogram plot
metrics.list_n500=readRDS('Robustness_metrics_463solns_List.rds')
metrics.list_n300=readRDS('Robustness_metrics_463solns_List_300SOW.rds')

metrics.list_n500[['optimization']]=metrics_4app_n500$optimization
metrics.list_n300[['optimization']]=metrics_4app_n300$optimization

# for consistency, change satisficing.LBSV to satisficing.LB.Shortage.Volume
colnames(metrics_4app_n500$satisficing)=gsub(x=colnames(metrics_4app_n500$satisficing), pattern="LBSV", replacement = "LB.Shortage.Volume")
colnames(metrics_4app_n300$satisficing)=gsub(x=colnames(metrics_4app_n300$satisficing), pattern="LBSV", replacement = "LB.Shortage.Volume")
colnames(metrics.list_n500$satisficing)=gsub(x=colnames(metrics.list_n500$satisficing), pattern="LBSV", replacement = "LB.Shortage.Volume")
colnames(metrics.list_n300$satisficing)=gsub(x=colnames(metrics.list_n300$satisficing), pattern="LBSV", replacement = "LB.Shortage.Volume")

################### import data for stacked histogram plotting ##########################

bar_plot_data=readRDS(file='data for stacked bar plot.rds')
long_data=bar_plot_data$long_data
wide_data=bar_plot_data$wide_data
wide_data$ID=1:nrow(wide_data)

add_to_tradeoff_all=wide_data[4:8] # T1e, T1V, maxVol, nTiers to add to each df for filtering
add_to_tradeoff=dplyr::filter(add_to_tradeoff_all, ID %in% metrics.list_n500$satisficing$ID)[-ncol(add_to_tradeoff_all)]# minus five to remove ID

############## import DV so user can add to custom parallel coordinates #########
DV_prep=read.table('Archive_463_Condensed.txt')

DV=data.frame(ID=wide_data$ID, DV_prep, ntiers=add_to_tradeoff$nTiers, maxVol=add_to_tradeoff$maxVol)
metrics.list_n500[["decision variables"]]=DV
metrics.list_n300[["decision variables"]]=DV
metrics_4app_n500[["decision variables"]]=DV
metrics_4app_n300[["decision variables"]]=DV

############# turn robustness lists into reactive values so user can switch SOW ensemble ###########
metrics_4app=reactiveValues(l=metrics_4app_n500) # initialize app with n500 SOW ensemble
metrics.list=reactiveValues(l=metrics.list_n500)# initialize app with n500 SOW ensemble

observeEvent(input$SOWensemble, {
  
  if (input$SOWensemble=='cLHS n500'){
    metrics_4app$l=metrics_4app_n500
    metrics.list$l=metrics.list_n500
  } else if (input$SOWensemble=="cLHS n300") {
    metrics_4app$l=metrics_4app_n300
    metrics.list$l=metrics.list_n300
  } else {
    metrics_4app$l=metrics_4app_n500
    metrics.list$l=metrics.list_n500

  }
  
  
  
})


# scale mean_variance between 0 and 1

observe({

  colID=which(!(colnames(metrics_4app$l[['mean.variance']]) %in% c('ID', 'front')))

  for(i in colID){ # start in column three to skip ID and front
   max=max(metrics_4app$l$mean.variance[,i])
    replace=metrics_4app$l$mean.variance[,i]/max
  
    metrics_4app$l$mean.variance[,i]=replace
  }
})

###################### prepare robustness data frames ##################
########################################################################

global_filter=reactiveValues(r=1:463) # Initiate with all policies. changes whenever a user hits save button.
in_global_filter=reactiveValues(y=rep(1,nrow(wide_data)))

observe({ # create matrix of constraint ranges for PC ID axis
  a=global_filter$r-.001
  b=global_filter$r+.001
  global_filter$constraints=matrix(c(a,b),ncol=2, byrow = FALSE)})

# create prep dataframes, reactive to user changing SOW ensemble

prep=reactiveValues()


observe({
  
###### optimization objectives (in MOEA optimization)
prep$optimization=data.frame(metrics_4app$l$optimization, add_to_tradeoff)

###### LBSV < 600 KAF, Mead 1000 < 10% and Powell 3490 < 5%#####
prep$satisficing=data.frame(metrics_4app$l$satisficing, add_to_tradeoff)

##### % deviation
prep$percent_deviation=data.frame(metrics_4app$l$percent.deviation, add_to_tradeoff)

#### tradeoff between mean of objectives (Laplace PIR)
prep$Laplace=data.frame(metrics_4app$l$Laplaces.PIR, add_to_tradeoff)

#### tradeoff between mean-variance

prep$mean_var=data.frame(metrics_4app$l$mean.variance, add_to_tradeoff)

### regret from best tradeoffs
prep$regret2=data.frame(metrics_4app$l$regret.from.best, add_to_tradeoff)

#### tradeoffs between Hurwicz OP
prep$Hurwicz=data.frame(metrics_4app$l$Hurwicz.OP, add_to_tradeoff)

#### maximin (worst case SOW) tradeoffs
prep$maximin=data.frame(metrics_4app$l$maximin, add_to_tradeoff)

})

optimization=reactiveValues()

observe({
  
  optimization$all=prep$optimization
  optimization$g=dplyr::filter(prep$optimization, ID %in% global_filter$r)
  
})

###### update prep and optimization reactive values if user selects a subset with Kennard Stone #########

KS=reactiveValues(index=1:463) # preallocate KS index

observeEvent(input$KSApply,{ # Get KS index when user hits apply button in settings page
  
  req(isTruthy(input$KSmetric))  
  
  if (input$KSmetric=="Decision Variables") { # get ID ID from KenStone.samples
    temp=data.frame(ID=1:nrow(wide_data), DV_prep)
    data=dplyr::filter(temp, ID %in% global_filter$r) # input data is DV of policies in global filter
    tempi=kenStone(X=scale(data[-1]), k=input$KSnSample)$model # get row indices of Ken Stone samples from DV data. By subsetting temp to global filter policies, you are sampling from policies contained in global filters only
    KS$index=data[["ID"]][tempi] # convert row indices to ID ID. save in KS$index
    
  } else { # optimization performance
    # KS$index=KenStone.samples$optimization[1:input$KSnSample]
    tempi=kenStone(X=scale(filter.optimization()[2:9]), k=input$KSnSample)$model # get row indices of Ken Stone samples from filter.optimization(). By using filter.optimization() as data, you are sampling from policies contained in intersection of global filters and local optimization filters.
    KS$index=filter.optimization()[["ID"]][tempi] # convert row indices to ID ID. save in KS$index
   
    
  }
  
  # if KenStone is used on all policies, the algorithm returns all but one ID. Easiest correction is to check for this circumstance than override KS$index to include all policies
    if (input$KSnSample == nrow(wide_data)){
      KS$index=1:nrow(wide_data)
    }
  
  
  if (nrow(prep[["optimization"]]) < input$KSnSample){ # if user tries to INCREASE the number of KS samples
    showNotification("# of samples > # of policies. Resetting polices to global filter.", type="warning", duration=7)
    
    prep$optimization=data.frame(metrics_4app$l$optimization, add_to_tradeoff)
    prep$satisficing=data.frame(metrics_4app$l$satisficing, add_to_tradeoff)
    prep$percent_deviation=data.frame(metrics_4app$l$percent.deviation, add_to_tradeoff)
    prep$Laplace=data.frame(metrics_4app$l$Laplaces.PIR, add_to_tradeoff)
    prep$mean_var=data.frame(metrics_4app$l$mean.variance, add_to_tradeoff)
    prep$regret2=data.frame(metrics_4app$l$regret.from.best, add_to_tradeoff)
    prep$Hurwicz=data.frame(metrics_4app$l$Hurwicz.OP, add_to_tradeoff)
    prep$maximin=data.frame(metrics_4app$l$maximin, add_to_tradeoff)
    
  }
  
  
  for (name in names(prep)){ # subset the prep dfs by KSindex
    prep[[name]]=dplyr::filter(prep[[name]], ID %in% KS$index)
  }

  
  
}, ignoreInit = F, ignoreNULL = F)

# need to subset all prep df again if user recalculates satisficing or Hurwicz

observeEvent(satisdf$trigger > 0 | Hurwicdf$trigger > 0, {
  
  for (name in names(prep)){ # subset the prep dfs by KSindex
    prep[[name]]=dplyr::filter(prep[[name]], ID %in% KS$index)
  }
  
  satisdf$trigger=0
  Hurwicdf$trigger=0
})

###### prepare reactiveValue global filters log object ######

df.initialize=data.frame(matrix(ncol=6, nrow=1), stringsAsFactors = FALSE)
colnames(df.initialize)=c("page", "metric", "filter.type", "lower", "upper", "table.selection.ID")

filterLog=reactiveValues(global=df.initialize, local=df.initialize)


```

```{r, settings Modal}

bsModal(id="modalSettings" ,title= "global plot settings", trigger="settingsOptimization",
        
h4('Parallel coordinates color scale'),
selectInput("ColorScale", label=NULL, selected='blue-red', choices=c('blue-red', 'Viridis','Picnic', 'Rainbow', 'Portland', 'Blackbody', 'Cividis', "YlGnBu", "Jet", "Hot", "Earth")),
bsTooltip(id="ColorScale", title="change the color gradient used in the parallel coordinates plot", placement = "right", options=list(container="body") ),
# bsPopover(id="ColorScale", title="test", content="change the color gradient used in the parallel coordinates plot")

h4('Reverse color scale?'),
prettyToggle("ReverseTF", label_on='   Yes   ', label_off='No', value=FALSE, width = '200px', bigger = T),
bsTooltip(id="ReverseTF", title="reverse the direction of parallel coordinates color scale. e.g: change blue-red to red-blue", placement = "right", options=list(container="body")),

h4('Keep or Remove policies from par coords?'),
prettyToggle("KeepPoliciesTF", label_on='Keep', label_off='Remove', value=FALSE, width = '200px', bigger=TRUE),
bsTooltip(id="KeepPoliciesTF", title="Should policies be removed from the parallel coordinates plot when they are filtered out? Note that policies are always removed from the decision variable plot. WARNING: When set to KEEP, policies removed from the global filter are shown in transparent gray in the parallel coordinates plot. Clicking on the ID axis will cause all policies to be shown in color.", placement = "right", options=list(container="body")),

h4("Maintain Par Coords axes ranges of all policies?"),
prettyToggle("MaintainAxes", label_on = "Yes", label_off="No", value=TRUE, width="200px", bigger = TRUE),
bsTooltip(id="MaintainAxes", title="Should the axes in parallel coordinates plots use the maximum ranges from all 463 policies, or should the range shrink as policies are removed?", placement = "right", options=list(container="body")),

h4('Select SOW ensemble'),
selectInput('SOWensemble', label=NULL, selected='cLHS n500', choices=c('cLHS n500', 'cLHS n300')),
bsTooltip(id="SOWensemble", title="Robustness metrics have been calculated using 500 states of the world (SOW) and 300 SOW. The Rank Correlation page demonstrates that the results are largely the same for both ensembles. However, you can choose which ensemble is shown in parallel coordinates and decision variable plots.", options=list(container="body"), placement = "right"),



h4("Subset policies with Kennard Stone sampling"),

selectInput("KSmetric", label="Metric", choices = c("Decision Variables", "Optimization objectives"), selected = "Decision Variables"),
bsTooltip(id="KSmetric", title="You can select a subset of policies to view in the parallel coordinates and decision variable plots using the Kennard-Stone algorithm, which identifies the k most diverse policies. Select if diversity is based on decision variables or optimization objectives, then choose k, the number of policies. The policies will be sampled from policies in the global filter.", options=list(container="body"), placement = "right"),

sliderInput("KSnSample", label = "Number of policies", min = 2, max=463, value=463, step=4),
actionButton("KSApply", label = "Subset policies")
        
        )

observeEvent(input$SOWensemble,{

  reset$SOWchange=1

}, ignoreNULL = TRUE, ignoreInit = TRUE)

modalTrigger=reactiveValues(Explore=0, Custom=0)

observeEvent(modalTrigger$Explore | modalTrigger$Custom, {
  
  # modalTrigger$Explore=0
  # modalTrigger$Custom=0
  
  toggleModal(session=session,'modalSettings', toggle = "open")
  


  
}, ignoreInit = T)

```



```{r, global filters and resets, include= FALSE}

### global reset

# to have better control over many action buttons, have the action buttons adjust reactiveValues. Then, use the reactive values to trigger resets. For reference: https://gist.github.com/aagarw30/316a65598b048476819dce76504d154d
reset=reactiveValues(
  Optimization=0,
  Custom=0,
  Explore=0
)

observeEvent(input$resetOptimization, {
  reset$Optimization=reset$Optimization+1
  reset$Custom=0
  reset$Explore=0
}, priority = 0,  ignoreNULL = TRUE, ignoreInit = TRUE)

observeEvent(input$resetCustom, {
  reset$Optimization=0
  reset$Custom=reset$Custom+1
  reset$Explore=0
}, priority = 0,  ignoreNULL = TRUE, ignoreInit = TRUE)

observeEvent(input$resetExplore, {
  reset$Optimization=0
  reset$Custom=0
  reset$Explore=reset$Explore+1
}, priority = 0,  ignoreNULL = TRUE, ignoreInit = TRUE)

observeEvent(eventExpr = {reset$Optimization > 0 | reset$Custom > 0 | reset$Explore > 0},
             {global_filter$r=1:nrow(wide_data)

            showNotification('Global filter is reset', type='message', duration=7)

             in_global_filter$y=rep(1,nrow(wide_data))
             rangesExplore$a=NULL
             ranges$a=NULL
             rangesCustom$a=NULL
             filterLog$global=df.initialize
             filterLog$local=df.initialize}, priority = 10, ignoreNULL = TRUE, ignoreInit = TRUE)

### global filter column to add to data frames for coloring par coords
observeEvent(eventExpr = {input$global_filterOptimization | input$global_filterExplore | input$global_filterCustom}, {all=1:nrow(wide_data)
y=rep(1,length(all))
y[which(!(all %in% global_filter$r))]=0
in_global_filter$y=y
# cat(file=stderr(), 'global filter bin:', in_global_filter$y, "\n") # prints dimension to R console
# cat(file=stderr(), 'global filter:', global_filter$r, "\n") # prints dimension to R console
ranges$a=NULL
rangesExplore$a=NULL
rangesCustom$a=NULL}, priority =-1, ignoreNULL = TRUE, ignoreInit = TRUE)

```


For reference {data-orientation=columns}
=====================================

Column {.tabset .tabset-fade data-width=600}
-------------------------------------

### background information


```{r, background image}
include_graphics('https://i.imgur.com/kYxboar.png')

```

### robustness metrics

```{r, robustness metrics documentation}
tags$iframe(style="height:1000px; width:100%; scrolling=yes",
src="www/Robustness pdf for app.pdf")
```

Optimization objectives {data-orientation=rows}
=====================================  

Column {.sidebar data-width=225}
------------------------------------

```{r, Optimization UI}

h3('Local filters')
dropdownButton(circle=F, label='manual filters', width=190,
selectInput("VarOptimization1", label = "Filter 1:",
            choices = get_options('optimization'), selected = 'None'),
selectInput("IneqOptimization1", label = "Inequality 1:",
            choices = c('<', '>'), selected = '<'),
textInput('ThreshOptimization1', label= 'Threshold 1:', value='', placeholder='10'),

selectInput("VarOptimization2", label = "Filter 2:",
            choices = get_options('optimization'), selected = 'None'),
selectInput("IneqOptimization2", label = "Inequality 2:",
            choices = c('<', '>'), selected = '<'),
textInput('ThreshOptimization2', label= 'Threshold 2:', value='', placeholder='10'),

selectInput("VarOptimization3", label = "Filter 3:",
            choices = get_options('optimization'), selected = 'None'),
selectInput("IneqOptimization3", label = "Inequality 3:",
            choices = c('<', '>'), selected = '<'),
textInput('ThreshOptimization3', label= 'Threshold 3:', value='', placeholder='10'),

textInput("IDOptimization", label='Select policy IDs', placeholder='eg: 292,54')         
               
               )

div(style="margin-bottom:20px") # adds padding between buttons
actionButton('manualfilterOptimization',label='save manual filters', width=190)
div(style="margin-bottom:5px") # adds padding between buttons
actionButton('brushfilterOptimization',label='save brush filters', width=190)
div(style="margin-bottom:5px") # adds padding between buttons

h4("table selections:", align="center")

fluidRow(column(width=3,
  actionButton('tableKeepOptimization',label='keep', width=91)),
  column(width=3, offset=2,
  actionButton("tableRemoveOptimization", label="remove", width=93))
  )



div(style="margin-bottom:5px") # adds padding between buttons
actionButton('localresetOptimization',label='reset local filters', width=190)
div(style="margin-bottom:20px") # adds padding between buttons

h3('Global filters')
actionButton('global_filterOptimization', label='save filters globally', width=190)
div(style="margin-bottom:5px") # adds padding between buttons
actionButton('resetOptimization',label='reset global filters', width=190)


h3('Plot variables')
selectInput('colorOptimization', label='ParCoords color variable', choices=c(get_options('optimization'),'global.filter'), selected = 'Mead.1000', width=190)

selectInput('xAxisOptimization', label = 'Metric for ranking', choices=get_options('optimization')[-1], selected='Mead.1000', width=190)

div(style="margin-bottom:20px") # adds padding between buttons

downloadButton("download_b",label="Download filtered policies", width=190)

downloadHandler(filename="optimization filtered policies.xlsx", content=function(file) {
  
  # remove empty rows in the log objects
  data=filterLog$global
  global=data[rowSums(is.na(data)) != ncol(data),]
  data=logOptimization$log
  local=data[rowSums(is.na(data)) != ncol(data),]

  data.list=list("policies"=select(filter.optimization(), -starts_with("X")), "global.filters"=global, "local.filters"=local)
  write.xlsx(data.list, file)

})

div(style="margin-bottom:60px") # adds padding between buttons

fluidRow(column(12, div(circleButton(inputId= "settingsOptimization", icon=icon("chart-line"), status = "primary")
, style="float: right")))
bsTooltip(id="settingsOptimization",title="global plot settings", options=list(container="body"), placement = "left")


# actionButton(inputId= "settings", label= "", icon=icon("chart-line") )
# dropdownButton(icon=icon("chart-line"), circle=T, right=T, up=T)

```


```{r, Optimization process UI, include=FALSE}
#### initialize with all 463 policies
policiesIDOptimization=reactiveValues(r=1:nrow(wide_data))
manualIDOptimization=reactiveValues(r=1:nrow(wide_data))
interactiveIDOptimization=reactiveValues(r=1:nrow(wide_data))

logOptimization=reactiveValues(log=df.initialize)
#### update manualIDOptimization based on user input

observeEvent(input$manualfilterOptimization, {
  
  temp=manual_filters(ID_key='IDOptimization', unique_thresh_ID = 'Optimization',dataframe = optimization$g, page="optimization") # returns list of ID and log
  manualIDOptimization$r=temp[[1]]
  
  logOptimization$log=rbind(logOptimization$log, temp[[2]])
  
}, ignoreInit = T, ignoreNULL = T)

#### update interactiveIDOptimization based on par coords brushing
ranges <- reactiveValues(a=list())

#### get ranges from brushing

observeEvent(eventExpr = event_data("plotly_restyle", source = "pcoords"),{
  temp=get_brush_ranges(source = "pcoords", prep_df = prep$optimization)
  if (is.na(temp)){
    # do nothing
  } else {
     ranges$a[[temp[[1]]]]=temp[[2]]
     
  }
})

#### get policies from brushing
observeEvent(input$brushfilterOptimization,{
  temp=get_brush_policyID(ranges=ranges$a, prep_df = prep$optimization, page="optimization") # returns list of policy IDs and log
  interactiveIDOptimization$r=temp[[1]]
  
  # update log
  
  logOptimization$log=rbind(logOptimization$log, temp[[2]])
})

### update policiesIDOptimization as intersection of global filter, manual filter, and interactive filter

observe({
  a=intersect(manualIDOptimization$r, interactiveIDOptimization$r)
  b=intersect(a, global_filter$r)
  
  policiesIDOptimization$r=b
}
)



observeEvent(input$tableKeepOptimization, {
  
  policiesIDOptimization$r=intersect(policiesIDOptimization$r, tableSelectOptimization$id)
  
  add_vec=c("Optimization", "ID", "table keep", NA, NA, paste(as.character(tableSelectOptimization$id), collapse=","))
  
  temp=df.initialize
  temp[1,]=add_vec
  
  logOptimization$log=rbind(logOptimization$log,temp)
  
}, ignoreInit = T)

observeEvent(input$tableRemoveOptimization, {
  
  all=1:nrow(wide_data)
  subset=all[-tableSelectOptimization$id]
  
  policiesIDOptimization$r=intersect(policiesIDOptimization$r, subset)
  
  add_vec=c("Optimization", "ID", "table remove", NA, NA, paste(as.character(tableSelectOptimization$id), collapse=","))
  temp=df.initialize
  temp[1,]=add_vec
  logOptimization$log=rbind(logOptimization$log, temp)
  
}, ignoreInit = T)



### establish filter.optimization

filter.optimization=reactive({ # because optimization() already accounts for global filter, filter.optimization is intersection of global and local POLICY ID filter only
  
  dplyr::filter(optimization$g, ID %in% policiesIDOptimization$r)
  
})

### apply global filter

observeEvent(input$global_filterOptimization, {
  
  global_filter$r=intersect(global_filter$r, policiesIDOptimization$r)
  
  remaining=length(global_filter$r)
  showNotification(paste(remaining, 'policies remain in global filter', sep=' ' ), type='message', duration=7)
  
  #transfer local log to global log
  filterLog$global=rbind(filterLog$global, logOptimization$log)
  
})


### local reset button

observeEvent(input$localresetOptimization, {
  policiesIDOptimization$r=1:nrow(wide_data)
  manualIDOptimization$r=1:nrow(wide_data)
  interactiveIDOptimization$r=1:nrow(wide_data)
  tableSelectOptimization$id=NULL
  ranges$a=NULL
  logOptimization$log=df.initialize
})

  # also, if color changes, reset local filters

observeEvent(input$colorOptimization,{
  #   policiesIDOptimization$r=1:nrow(wide_data)
  # manualIDOptimization$r=1:nrow(wide_data)
  interactiveIDOptimization$r=1:nrow(wide_data)
  ranges$a=NULL
  
  rows=which(logOptimization$log$filter.type=="brush")
  logOptimization$log=logOptimization$log[-rows,]
  
})

```

Row {data-height=325}    
-------------------------------------
### optimization objectives  

```{r, Optimization par_coords}

labelsOptimization=colnames(metrics_4app_n500$optimization)


plotlyOutput("pc1")


output$pc1=renderPlotly({
  
  isTruthy(input$localresetOptimization) # adding this statement causes interactive filters to reset,
  
  if (input$KeepPoliciesTF==TRUE){
    data=data.frame(optimization$all,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.optimization()
  } else {
    data=data.frame(optimization$all,global.filter=in_global_filter$y[KS$index])
  }

  
  ## create matrix of policy ID constraints that considers both the global filter plus table selections
  bind=rbind(tableSelectOptimization$constraints, global_filter$constraints) # bind table and global filter matrices
  
  if(TRUE %in% duplicated(bind)){ # check if any duplicate rows. If so, then the user has selected data in the table and only that should be highlighted
    policy_ID_constraints=bind[duplicated(bind),]
  } else {
    policy_ID_constraints=global_filter$constraints # if no duplicates, then color only policies in global filter
  }

  p=par_coords(data=data, n_var=9,
             color_var = input$colorOptimization, title='Optimization objectives', labels=labelsOptimization, source='pcoords', policy_ID = policy_ID_constraints, colorbarTitle = input$colorOptimization, axes_data=metrics.list_n500$optimization)
  p=event_register(p,"plotly_restyle")
  p
  
})



```

Row {.tabset .tabset-fade data-height=275}    
-------------------------------------
    
### Rank of filtered policies for selected metric
    
```{r}
############# Optimization DV plot

renderPlotly({

  input$resetOptimization

  DV_plot(metric=data.frame(metrics.list$l$optimization, add_to_tradeoff), to_plot = filter.optimization()[["ID"]], preferred_direction = 'min',
          metric_label = input$xAxisOptimization)
  

})

```

### Table of filtered policies

```{r}
  output$optimization_data <- DT::renderDataTable({
    input$localresetOptimization
    select(filter.optimization(), -starts_with("X"))
  },options = list(scrollY="245px", scrollX="100px", pageLength=10), server = TRUE, filter="none", rownames=FALSE
)

DT::dataTableOutput("optimization_data")

tableSelectOptimization=reactiveValues(id=NULL)


observe({
  tableSelectOptimization$id=filter.optimization()[['ID']][input$optimization_data_rows_selected]
  a=tableSelectOptimization$id-.001
  b=tableSelectOptimization$id+.001
  tableSelectOptimization$constraints=matrix(c(a,b),ncol=2, byrow = FALSE)})



```



Robustness metrics {data-orientation=rows}
==========================================

Column{.sidebar data-width=225}
-------------------------------

```{r, satisficing calcs data}
obj_all=read.table('objectives_all463.txt') # load data for calculating robustness

vol_index=which(colnames(obj_all) %in% c('LB.Shortage.Volume',"LB.Shortage.Volume.Policy", "Max.Annual.LB.Shortage"))
obj_all[,vol_index]=obj_all[,vol_index]/1000 # convert to KAF
obj_all[["Powell.WY.Release"]]=obj_all[["Powell.WY.Release"]]/(10^6) # convert to MAF


SOW_500_300_100=readRDS("SOW ensemble 500_300_100.rds") # list of SOW ensembles
SOW_id=sort(SOW_500_300_100[[2]]$model) # SOW IDs of the 300 member SOW ensemble

```

```{r, Exploration UI}

df_names=names(metrics_4app_n500)
name=reactiveValues(n='satisficing')
observeEvent(input$active_tab,{
    name$n=df_names[input$active_tab+1]
    # cat(file=stderr(), 'name$n=', name$n, "\n") # prints page name to console for debugging
})

# Hurwicz
renderUI({
  req(name$n=="Hurwicz.OP")
  sliderInput("HurwicWeight", label="Best-case weight", min=0, max=1, value=0.5, step=0.05, width=170, ticks = F)
})

renderUI({
  req(name$n=="Hurwicz.OP")
  req(Hurwicdf$calcWeight != input$HurwicWeight) # only give option to calculate if weight has changed
  
  actionButton("HurwicCalc", label= "update weight", width=190, class="btn-warning")
  
})

# satisficing

renderUI({
  req(name$n=="satisficing")

  dropdownButton(label='Satisficing calcs', circle = F, width = 220,

  selectInput("satisObj",label="Select objective(s)", multiple = T, choices=colnames(obj_all)[-c(1,2)]),

  renderUI({
    req(length(input$satisObj) >=1)
    sliderInput("satisThresh1", label=paste0(input$satisObj[1], " threshold"), min=min(obj_all[[input$satisObj[1]]]),
                max=max(obj_all[[input$satisObj[1]]]), value=median(obj_all[[input$satisObj[1]]]))
    }),

    renderUI({
    req(length(input$satisObj) >=2)
    sliderInput("satisThresh2", label=paste0(input$satisObj[2], " threshold"), min=min(obj_all[[input$satisObj[2]]]),
                max=max(obj_all[[input$satisObj[2]]]), value=median(obj_all[[input$satisObj[2]]]))
    }),

    renderUI({
    req(length(input$satisObj) >=3)
    sliderInput("satisThresh3", label=paste0(input$satisObj[3], " threshold"), min=min(obj_all[[input$satisObj[3]]]),
                max=max(obj_all[[input$satisObj[3]]]), value=median(obj_all[[input$satisObj[3]]]))
    }),

    renderUI({
    req(length(input$satisObj) >=4)
    sliderInput("satisThresh4", label=paste0(input$satisObj[1], " threshold"), min=min(obj_all[[input$satisObj[4]]]),
                max=max(obj_all[[input$satisObj[4]]]), value=median(obj_all[[input$satisObj[4]]]))
    }),

    renderUI({
    req(length(input$satisObj) >=5)
    sliderInput("satisThresh5", label=paste0(input$satisObj[5], " threshold"), min=min(obj_all[[input$satisObj[5]]]),
                max=max(obj_all[[input$satisObj[5]]]), value=median(obj_all[[input$satisObj[5]]]))
    }),

    renderUI({
    req(length(input$satisObj) >=6)
    sliderInput("satisThresh6", label=paste0(input$satisObj[6], " threshold"), min=min(obj_all[[input$satisObj[6]]]),
                max=max(obj_all[[input$satisObj[6]]]), value=median(obj_all[[input$satisObj[6]]]))
    }),

    renderUI({
    req(length(input$satisObj) >=7)
    sliderInput("satisThresh7", label=paste0(input$satisObj[7], " threshold"), min=min(obj_all[[input$satisObj[7]]]),
                max=max(obj_all[[input$satisObj[7]]]), value=median(obj_all[[input$satisObj[7]]]))
    }),

    renderUI({
    req(length(input$satisObj) >=8)
    sliderInput("satisThresh8", label=paste0(input$satisObj[8], " threshold"), min=min(obj_all[[input$satisObj[8]]]),
                max=max(obj_all[[input$satisObj[8]]]), value=median(obj_all[[input$satisObj[8]]]))
    }),

  div(style="margin-bottom:20px"), # adds padding between buttons

  renderUI({
    req(length(input$satisObj) >=2)
    h4('Aggregate objectives?')
    prettyToggle("AggTF", value=FALSE, label_on = "Aggregrate objectives", label_off = "Don't aggregrate objectives", width = '200px', bigger=T)
    }),

  div(style="margin-bottom:20px"), # adds padding between buttons

  renderUI({
    req(length(input$satisObj) >=1)
    actionButton("CalcSatis", label="Calculate")
  })

                   )

})

# get options for manual filters, par coords color var, and x axis
observe({
    req(name$n)
  
  if (name$n=="satisficing"){ # special function for satisficing because user can change names of the axes
    Explore_all$options=get_satisficing_options()[-1]
  } else {
    Explore_all$options=get_options(name$n)[-1]
  }
})

h3('Local filters')
dropdownButton(label='manual filters', circle = F, width = 190,
               
renderUI({
  req(name$n)
  selectInput("VarExplore1", label = "Filter 1:",
            choices = c("None", Explore_all$options), selected = 'None')
}),

renderUI({
    req(name$n)
    selectInput("IneqExplore1", label = "Inequality 1:",
            choices = c('<', '>'), selected = '<')
}),

renderUI({
  req(name$n)
  textInput('ThreshExplore1', label= 'Threshold 1:', value='', placeholder='10')

}),

renderUI({
  req(name$n)
  selectInput("VarExplore2", label = "Filter 2:",
            choices = c("None", Explore_all$options), selected = 'None')
}),

renderUI({
      req(name$n)
    selectInput("IneqExplore2", label = "Inequality 2:",
            choices = c('<', '>'), selected = '<')
  
}),

renderUI({
    req(name$n)
  textInput('ThreshExplore2', label= 'Threshold 2:', value='', placeholder='10')

}),

renderUI({
  req(name$n)
  selectInput("VarExplore3", label = "Filter 3:",
            choices = c("None", Explore_all$options), selected = 'None')
}),

renderUI({
      req(name$n)
    selectInput("IneqExplore3", label = "Inequality 3:",
            choices = c('<', '>'), selected = '<')
  
}),

renderUI({
    req(name$n)
  textInput('ThreshExplore3', label= 'Threshold 3:', value='', placeholder='10')

}),

renderUI({
  req(name$n)
  textInput("IDExplore", label='Select policy IDs', placeholder='eg: 292,54')
})

)


div(style="margin-bottom:5px") # adds padding between buttons
renderUI({
  req(name$n)
  actionButton('manualfilterExplore', 'save manual filters', width=190)
})

div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(name$n)
  actionButton('brushfilterExplore',label='save brush filters', width=190)

})
div(style="margin-bottom:5px") # adds padding between buttons

h4("table selections:", align="center")

renderUI({
  req(name$n)
  
  fluidRow(column(width=3,
    actionButton('tableKeepExplore',label='keep', width=91)),
    column(width=3, offset=2,
    actionButton("tableRemoveExplore", label="remove", width=93))
    )

})
div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(name$n)
  actionButton('localresetExplore',label='reset local filters', width=190)

})
div(style="margin-bottom:10px") # adds padding between buttons


h3("Global filters")
renderUI({
  req(name$n)
  actionButton('global_filterExplore', label='save filters globally', width=190)
})
div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(name$n)
  actionButton('resetExplore',label='reset global filters', width=190)
})

div(style="margin-bottom:5px") # adds padding between buttons


h3("Plot variables")
renderUI({
  req(name$n)

  selectInput('colorExplore', label='ParCoords color variable', choices=c(Explore_all$options, 'global.filter', 'front'), selected = Explore_all$options[1], width=190)

})

renderUI({
  req(name$n)
  
  selectInput('xAxisExplore', label = 'Metric for ranking', choices=Explore_all$options, selected=Explore_all$options[1], width=190)
})


downloadButton("download_Explore",label="Download filtered policies")


downloadHandler(filename="Exploration filtered policies.xlsx", content=function(file) {
  
    # remove empty rows in the log objects
  data=filterLog$global
  global=data[rowSums(is.na(data)) != ncol(data),]
  data=logExplore$log
  local=data[rowSums(is.na(data)) != ncol(data),]

  data.list=list("policies"=select(filter.Explore(), -starts_with("X")), "global.filters"=global, "local.filters"=local)
  write.xlsx(data.list, file)

})

div(style="margin-bottom:30px") # adds padding between buttons

fluidRow(column(12, div(circleButton(inputId= "settingsExplore", icon=icon("chart-line"), status = "primary")
, style="float: right")))
bsTooltip(id="settingsExplore",title="global plot settings", options=list(container="body"), placement = "left")

observeEvent(input$settingsExplore, {modalTrigger$Explore=1+modalTrigger$Explore}, ignoreInit = T)


```



<script>
 $("body").on("shown.bs.tab", "a[data-toggle='tab']", function(e){
    Shiny.setInputValue("active_page", window.location.href);
 })
</script>

<script>
 $("body").on("shown.bs.tab", "div[id='section-row-2']", function(e){
    Shiny.setInputValue("active_tab", $(e.target).parent().index());
 })
</script>



```{r, Exploration process tabs, include=FALSE}

# the above JavaScript code was taken originally from here:
# https://stackoverflow.com/questions/64306794/how-to-get-the-current-active-tab-in-a-flexdashboard-document-to-reactively-disp

# I created two versions of the script from stackoverflow to perform two tasks, each using the jquery on(events [,selector], handler) function differently. Both on() function calls look for user to click. Then, the selecter argument and handler argument differs

# The first script uses the selector 'a[data-toggle='tab']' and the handler saves the page url via window.location.href. This means whenever a tab is toggled, the url is saved to input$active_page. I use this to track when 'Metric exploration' page is active
# see here for window.location.href: https://www.w3schools.com/js/js_window_location.asp
# see here for on() function: https://api.jquery.com/on/


# The second script tracks the tab index of the active par-coords in Metric exploration page. To avoid the tab index changing when on other pages or when changing between DV plot and table, I use the selector "div[id='section-row-2']". I discovered that this selector is unique to the Metric exploraiton page and par_coords (top) row. The bottom row (DV plot and table) has id='section-row-3', so changes in the tabs there are not registered as an event. I figured this out by opening the .html console log then exploring through the elements tab. To reach the .html console log, right click on the app when opened in a browser then selcect 'Inspect'



# preallocate reactiveValues used to track which page and tab the user is on
page=reactiveValues(ID="for-reference")
tab=reactiveValues(ID=0)
# count=reactiveValues(c=0)

# get the name of the active page. ie, optimization, for reference, metric exploration
observeEvent(input$active_page, {
  extract=sub(".*/#section-", "", input$active_page) # obtain characters after /#section- in the html address
  page$ID=extract
  # cat(file=stderr(), 'page$ID=', page$ID, "\n") # prints page name to console for debugging
  # cat(file=stderr(), 'input$active_page=', input$active_page, "\n") # prints page name to console for debugging

})


Explore_all=reactiveValues(df=metrics_4app_n500$satisficing, options=get_options("satisficing")[-1], axes=metrics_4app_n500$satisficing, ID_constraints=NULL)


observe({
  if (!isTruthy(input$active_tab)){
    Explore_all$df=prep$satisficing
    Explore_all$axes=metrics_4app$l$satisficing
  } else if (input$active_tab==0){
    Explore_all$df=prep$satisficing
    Explore_all$axes=metrics_4app$l$satisficing
  } else if (input$active_tab==1){
    Explore_all$df=prep$regret2
    Explore_all$axes=metrics_4app$l$regret.from.best
  } else if (input$active_tab==2){
    Explore_all$df=prep$percent_deviation
    Explore_all$axes=metrics_4app$l$percent.deviation
  } else if (input$active_tab==3){
    Explore_all$df=prep$Laplace
    Explore_all$axes=metrics_4app$l$Laplaces.PIR
  } else if (input$active_tab==4){
    Explore_all$df=prep$Hurwicz
    Explore_all$axes=metrics_4app$l$Hurwicz.OP
  } else if (input$active_tab==5){
    Explore_all$df=prep$mean_var
    Explore_all$axes=metrics_4app$l$mean.variance
  } else if (input$active_tab==6) {
    Explore_all$df=prep$maximin
    Explore_all$axes=metrics_4app$l$maximin
  } else {
    Explore_all$df=prep$satisficing
    Explore_all$axes=metrics_4app$l$satisficing

  }

})

Explore=reactiveValues()


observe({
  Explore$df=dplyr::filter(Explore_all$df, ID %in% global_filter$r)
})


```

```{r, process Exploration UI}


#### initialize with all 463 policies
policiesIDExplore=reactiveValues(r=1:nrow(wide_data))
manualIDExplore=reactiveValues(r=1:nrow(wide_data))
interactiveIDExplore=reactiveValues(r=1:nrow(wide_data))

logExplore=reactiveValues(log=df.initialize)

#### update manualIDExplore based on user input

observeEvent(input$manualfilterExplore, {
  temp=manual_filters(ID_key='IDExplore', unique_thresh_ID = 'Explore',dataframe = Explore$df, page=paste0("Explore.",name$n))
  manualIDExplore$r=temp[[1]]
  
  logExplore$log=rbind(logExplore$log, temp[[2]])
})

#### update interactiveIDExplore based on par coords brushing
rangesExplore <- reactiveValues(a=list())

#### get ranges from brushing

observeEvent(eventExpr = event_data("plotly_restyle", source = name$n),{

  temp=get_brush_ranges(source = name$n, prep_df = Explore_all$df)
    if (is.na(temp)){
    # do nothing
  } else {
     rangesExplore$a[[temp[[1]]]]=temp[[2]]
     
  }
  # cat(file=stderr(), 'trying to filter df:', name$n, "\n")
  # cat(file=stderr(), 'trying to filter metric:', temp[[1]], "\n")

})

#### get policies from brushing

observeEvent(input$brushfilterExplore,{

  temp=get_brush_policyID(ranges=rangesExplore$a, prep_df = Explore_all$df, page=paste0("Explore.",name$n))
  
  interactiveIDExplore$r=temp[[1]]
  
  # update log
  
  logExplore$log=rbind(logExplore$log, temp[[2]])
  
})


### update policiesIDExplore as intersection of global filter, manual filter, and interactive filter

observe({
  a=intersect(manualIDExplore$r, interactiveIDExplore$r)
  b=intersect(a, global_filter$r)
  policiesIDExplore$r=b
}
)

### update policies for selections from table
observeEvent(input$tableKeepExplore, {
  policiesIDExplore$r=intersect(policiesIDExplore$r, tableSelectExplore$id)
  
  add_vec=c(paste0("Explore.", name$n), "ID", "table keep", NA, NA, paste(as.character(tableSelectExplore$id), collapse=","))
  temp=df.initialize
  temp[1,]=add_vec
  logExplore$log=rbind(logExplore$log, temp)
  
}, ignoreInit = T)

observeEvent(input$tableRemoveExplore, {
  
  all=1:nrow(wide_data)
  subset=all[-tableSelectExplore$id]
  
  policiesIDExplore$r=intersect(policiesIDExplore$r, subset)
  
  add_vec=c(paste0("Explore.", name$n), "ID", "table remove", NA, NA, paste(as.character(tableSelectExplore$id), collapse=","))
  temp=df.initialize
  temp[1,]=add_vec
  logExplore$log=rbind(logExplore$log, temp)
  
}, ignoreInit = T)

### establish filter.Explore

filter.Explore=reactive({ # because Explore$df already accounts for global filter, filter.Explore is intersection of global and local POLICY ID filter only

  dplyr::filter(Explore$df, ID %in% policiesIDExplore$r)

})

### apply global filter

observeEvent(input$global_filterExplore, {
  global_filter$r=intersect(global_filter$r, policiesIDExplore$r)
  
  remaining=length(global_filter$r)
  showNotification(paste(remaining, 'policies remain in global filter', sep=' ' ), type='message', duration=7)
  
  filterLog$global=rbind(filterLog$global, logExplore$log)
})


### local reset button

observeEvent(name$n,{ # wipe clean the brush filters when you change pages, or you will have brush ranges on previous pages affect your current page
  rangesExplore$a=NULL
  interactiveIDExplore$r=1:nrow(wide_data)

})


observeEvent(input$localresetExplore, {
  policiesIDExplore$r=1:nrow(wide_data)
  manualIDExplore$r=1:nrow(wide_data)
  interactiveIDExplore$r=1:nrow(wide_data)
  tableSelectExplore$id=NULL
  rangesExplore$a=NULL
  logExplore$log=df.initialize
})

  # also, if color changes, reset local filters

observeEvent(input$colorExplore,{
  #   policiesIDExplore$r=1:nrow(wide_data)
  # manualIDExplore$r=1:nrow(wide_data)
  interactiveIDExplore$r=1:nrow(wide_data)
  rangesExplore$a=NULL
  
  rows=which(logExplore$log$filter.type=="brush")
  logExplore$log=logExplore$log[-rows,]
  
})


```


Row {.tabset .tabset-fade data-height=325}
-------------------------------------------


```{r, calculate satisficing}
# create unit mapping. I use this to update Par Coords title
units=data.frame(LB.Shortage.Volume="KAF", LB.Shortage.Volume.Policy="KAF", Lee.Ferry.Deficit= "%", Mead.1000="%",
                 Powell.3490="%", LB.Max.Cons.Shortage.Duration="Yr", LB.Shortage.Frequency="%", Max.Annual.LB.Shortage="KAF", Powell.WY.Release="MAF")


satisdf=reactiveValues(df=metrics.list_n500$satisficing, trigger=0, title="Satisficing: Mead.1000 < 10% & Powell.3490 < 5% & LB.Shortage.Volume < 600KAF", AggTF=FALSE) # establish reactive object to store satisficing dataframe

# update AggTF with user input
observeEvent(input$AggTF, {
  satisdf$AggTF=input$AggTF
})

observeEvent(input$CalcSatis, {
  
  showNotification('Calculating', type='message', duration=7)
  
  satisdf$df=NULL # reset satisdf
  
  # change the ensemble based on user input
  if (input$SOWensemble=="cLHS n300"){
    obj=dplyr::filter(obj, TraceNumber %in% SOW_id) # filter CRSS objectives output to the 300 SOW
  } else {
    obj=obj_all
  }
  
  # names=input$satisObj
  # cat(file=stderr(), 'names:', names, "\n")
  
  # create thresholds vector
  thresholds=vector() # create vector
  satisdf$title="Satisficing:"
  for (i in 1:8){
    if(is.null(input[[paste0("satisThresh",i)]])){ # if Null, exit loop
      break
    } else {
      thresholds[i]=input[[paste0("satisThresh",i)]]
      add_to_title=paste0(input$satisObj[i], " < ", thresholds[i], units[[input$satisObj[i]]])
    }
    
    
    if (i==1){
      satisdf$title=paste(satisdf$title, add_to_title, sep=" ")
    } else {
      satisdf$title=paste(satisdf$title, "&", add_to_title, sep=" ")
    }
    
  }
  
  # thresholds=unlist(lapply(str_split(input$satisThresh, ','), as.integer))
  # check=input$satisThresh
  # cat(file=stderr(), 'thresholds:', thresholds, "\n")
  
  if(satisdf$AggTF == TRUE){
    # calculate satisficing
    df=satisficing(data=obj, objectives = input$satisObj, thresholds = thresholds)
    colnames(df)[2]="satisficing"
    
    add=satisficing.deviation(data=obj, objectives = input$satisObj, thresholds = thresholds)[,2]
    df=cbind(df,add)
    colnames(df)[3]="sat.deviation"
    
  } else {
    # for loop to calculate satisficing for each objective
    
      for (i in 1:length(input$satisObj)){ # satisficing
        
        if(i==1){# initialize df
          df=satisficing(data=obj, objectives = input$satisObj[i], thresholds=thresholds[i])
          colnames(df)[2]=paste0('satisficing.',input$satisObj[i])
        } else { #
          add=satisficing(data=obj, objectives = input$satisObj[i], thresholds=thresholds[i])[,2]
          df=cbind(df,add)
          colnames(df)[ncol(df)]=paste0('satisficing.',input$satisObj[i])
          
        }
        
      } # end satisficing
    
      for (i in 1:length(input$satisObj)){ #satisficing deviation
        
        add=satisficing.deviation(data=obj, objectives = input$satisObj[i], thresholds = thresholds[i])[,2]
        df=cbind(df,add)
        colnames(df)[ncol(df)]=paste0("sat.dev.",input$satisObj[i])
        
      }
    
  }
  
  satisdf$df=df # update satisdf
#   check=dim(satisdf$df)
# cat(file=stderr(), 'dimensions:', check, "\n") # prints dimension to R console

    metrics.list$l$satisficing=df # update both metrics list. prep$satisficing will update because of dependency
    metrics_4app$l$satisficing=df
    
    satisdf$trigger=1 # triggers subsetting of prep$satisficing by KS$index

  showNotification('Satisficing thresholds updated', type='message', duration=7)
  
})


```


### Satisficing-related
```{r, satisficing par coords}

plotlyOutput("pcSatisficing")


observe({
    ## create matrix of policy ID constraints that considers both the global filter plus table selections
  bind=rbind(tableSelectExplore$constraints, global_filter$constraints) # bind table and global filter matrices
  
  if(TRUE %in% duplicated(bind)){ # check if any duplicate rows. If so, then the user has selected data in the table and only that should be highlighted
    Explore_all$ID_constraints=bind[duplicated(bind),]
  } else {
    Explore_all$ID_constraints=global_filter$constraints # if no duplicates, then color only policies in global filter
  }
})


output$pcSatisficing=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,

    if (input$KeepPoliciesTF==TRUE){
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.Explore()
  } else {
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  }
  
  nvar=which(colnames(Explore_all$df)==colnames(add_to_tradeoff)[1])-1 # find where add_to_tradeoff begins, substract one index
  max_cols=which(startsWith(colnames(Explore_all$df), "satisficing."))
  
  
  
  p=par_coords(data=data, n_var=nvar, 
             color_var = input$colorExplore, title=satisdf$title, labels=colnames(Explore_all$df)[1:nvar], max_cols = max_cols, source='satisficing', policy_ID = Explore_all$ID_constraints, colorbarTitle = input$colorExplore, axes_data=Explore_all$axes)
  p=event_register(p,"plotly_restyle")
  p
  
})


```

### Regret from best
```{r, par coords regret from best}

labelsregret.from.best=colnames(metrics_4app_n500$regret.from.best)

plotlyOutput("pcRegret.From.Best")


output$pcRegret.From.Best=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,

    if (input$KeepPoliciesTF==TRUE){
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.Explore()
  } else {
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  }
  
  
  p=par_coords(data=data, n_var=10, 
             color_var = input$colorExplore, title='Regret from best', labels=labelsregret.from.best, source='regret.from.best', policy_ID = Explore_all$ID_constraints, colorbarTitle = input$colorExplore, axes_data=Explore_all$axes)
  p=event_register(p,"plotly_restyle")
  p
  
})

```

### Percent deviation
```{r, par coords percent deviation}


labelsPercent.Deviation=colnames(metrics_4app_n500$percent.deviation)

plotlyOutput("pcPercent.Deviation")


output$pcPercent.Deviation=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,

  
    if (input$KeepPoliciesTF==TRUE){
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.Explore()
  } else {
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  }
  
  p=par_coords(data=data, n_var=10, 
             color_var = input$colorExplore, title='Percent deviation from optimization', labels=labelsPercent.Deviation, source='percent.deviation', policy_ID = Explore_all$ID_constraints, colorbarTitle = input$colorExplore, axes_data=Explore_all$axes)
  p=event_register(p,"plotly_restyle")
  p
  
})

```

### Laplace's PIR
```{r, par coords Laplaces PIR}

labelsLaplaces.PIR=colnames(metrics_4app_n500$Laplaces.PIR)

plotlyOutput("pcLaplaces.PIR")


output$pcLaplaces.PIR=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,

  
    if (input$KeepPoliciesTF==TRUE){
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.Explore()
  } else {
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  }
  
  
  p=par_coords(data=data, n_var=10, 
             color_var = input$colorExplore, title='Laplaces Principle of Insufficient Reason (mean)', labels=labelsLaplaces.PIR, source='Laplaces.PIR', policy_ID = Explore_all$ID_constraints, colorbarTitle = input$colorExplore, axes_data=Explore_all$axes)
  p=event_register(p,"plotly_restyle")
  p
  
})


```

### Hurwicz optimism-pessimism

```{r, HurwicOP calcs, include=FALSE}

Hurwicdf=reactiveValues(df=metrics.list_n500$Hurwicz.OP, calcWeight=0.5, trigger=0) # establish reactive object to store Hurwic dataframe

observeEvent(input$HurwicCalc, {
  
  showNotification('Calculating', type='message', duration=7)
  
  Hurwicdf$df=NULL # reset Hurwicdf
  
  # change the ensemble based on user input
  if (input$SOWensemble=="cLHS n300"){
    obj=dplyr::filter(obj, TraceNumber %in% SOW_id) # filter CRSS objectives output to the 300 SOW
  } else {
    obj=obj_all
  }
  
  df=HurwiczOP(data=obj, objectives=colnames(obj)[-c(1,2,4)], best_case_weight = input$HurwicWeight)
  
  Hurwicdf$df=df # update 

  Hurwicdf$calcWeight=input$HurwicWeight # update weight of current calculations

  metrics.list$l$Hurwicz.OP=df # update both metrics list. prep$Hurwicz updates because of dependency
  metrics_4app$l$Hurwicz.OP=df

  Hurwicdf$trigger=1
  
  showNotification('Hurwic OP weights updated', type='message', duration=7)
  
}, ignoreNULL = T, ignoreInit = T)



```



```{r}

labelsHurwicz.OP=colnames(metrics_4app_n500$Hurwicz.OP)


plotlyOutput("pcHurwicz.OP")


output$pcHurwicz.OP=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))

  weight=isolate(input$HurwicWeight) # I want title to reflect the weight without renderPlotly taking a dependency on it
  if (is.null(weight)){
    weight=0.5 # so the title is loaded with correct values upon app initialization
  }
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset when local reset button applied

    if (input$KeepPoliciesTF==TRUE){
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.Explore()
  } else {
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  }
  
  
  nvar=if("front" %in% colnames(data)) {10} else {9} # 10 axes if front is included, 9 otherwise
  
  p=par_coords(data=data, n_var=nvar, 
             color_var = input$colorExplore, title=paste0('Hurwicz Optimism-Pessimism: best-case weight = ', weight, " , worst-case weight = ", (1-weight) ), labels=labelsHurwicz.OP, source='Hurwicz.OP', policy_ID = Explore_all$ID_constraints, colorbarTitle = input$colorExplore, axes_data=Explore_all$axes)
  p=event_register(p,"plotly_restyle")
  p
  
})


```

### Mean-variance

```{r, par coords mean variance}

labelsmean.variance=colnames(metrics_4app_n500$mean.variance)

plotlyOutput("pcmean.variance")


output$pcmean.variance=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,

  
    if (input$KeepPoliciesTF==TRUE){
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.Explore()
  } else {
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  }
  
  p=par_coords(data=data, n_var=10, 
             color_var = input$colorExplore, title='mean-variance', labels=labelsmean.variance, source='mean.variance', policy_ID = Explore_all$ID_constraints, colorbarTitle = input$colorExplore, axes_data=Explore_all$axes)
  p=event_register(p,"plotly_restyle")
  p
  
})


```

### Maximin
```{r, par coords maximin}

labelsmaximim=colnames(metrics_4app_n500$maximin)


plotlyOutput("pcmaximin")


output$pcmaximin=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,

  
    if (input$KeepPoliciesTF==TRUE){
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.Explore()
  } else {
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  }
  
  p=par_coords(data=data, n_var=10, 
             color_var = input$colorExplore, title='maximin (worst case SOW)', labels=labelsmaximim, source='maximin', policy_ID = Explore_all$ID_constraints, colorbarTitle = input$colorExplore, axes_data=Explore_all$axes)
  p=event_register(p,"plotly_restyle")
  p
  
})


```

Row {.tabset .tabset-fade data-height=275}
------------------------------------------

### Rank of filtered policies for selected metric

```{r, Explore DV plot}

output$Explore_DV=renderPlotly({
  
  # check=dim(filter.Explore())
  # cat(file=stderr(), 'dim=', check, "\n") # prints dimension to R console
  # check=input$xAxisExplore
  # cat(file=stderr(), 'x axis=', check, "\n") # prints dimension to R console

  req(isTruthy(input$xAxisExplore)) # removes temporary error message caused by input$xAxisCustom not rendering until input$apply
  req(input$xAxisExplore %in% colnames(filter.Explore()))
  
  
  if(startsWith(input$xAxisExplore, 'satisficing')){
    max_or_min='max'
  } else {
    max_or_min='min'
  }
  
  req(isTruthy(filter.Explore()))
  req(nrow(filter.Explore())>0)
  req(name$n)
  
  # check=colnames(filter.Explore())
  # cat(file=stderr(), 'cols=', check, "\n") # prints dimension to R console
  # check=min_or_max_Explore$a
  # cat(file=stderr(), 'min or max =', check, "\n") # prints dimension to R console
  
  all_policies=data.frame(metrics_4app$l[[name$n]], add_to_tradeoff)
  
  DV_plot(metric=all_policies, to_plot = filter.Explore()[["ID"]], preferred_direction = max_or_min,
          metric_label = input$xAxisExplore)
  
})

outputOptions(output, name='Explore_DV', priority=-100)
  
plotlyOutput('Explore_DV')

```

### Table of filtered policies

```{r, explore table}

output$Explore_data <- DT::renderDataTable({
  select(filter.Explore(), -starts_with("X"))
}, options = list(scrollY="245px", scrollX="100px", pageLength=10), rownames=FALSE
)

DT::dataTableOutput("Explore_data")

tableSelectExplore=reactiveValues(id=NULL)

observe({
  tableSelectExplore$id=filter.Explore()[['ID']][input$Explore_data_rows_selected]
  a=tableSelectExplore$id-.001
  b=tableSelectExplore$id+.001
  tableSelectExplore$constraints=matrix(c(a,b),ncol=2, byrow = FALSE)})


```




Select your own{data-orientation=rows}
=======================================

Column{.sidebar data-width=235}
--------------------------------


```{r, custom UI}

metric_types=c("",names(metrics_4app_n500)) # add a blank element to beginning. This becomes default, and can be used to fail req()

# update satisficing in metrics_4app and metrics_list
metrics.list.react=reactiveValues(l=metrics.list_n500) # initiliaze
metrics_4app.react=reactiveValues(l=metrics_4app_n500) # initialize

observe({ # this observer will update metrics.list.react$l if the ensemble is changed by user
  metrics.list.react$l=metrics.list$l
  metrics_4app.react$l=metrics_4app$l
})


# metric selection drop down
h3('Select dimensions')
dropdownButton(
               
  selectInput("type1", label = "metric 1 type:",
            choices = metric_types),
renderUI({
  req(input$type1)
  selectInput('metric1', 'metric 1:', choices=colnames(metrics.list.react$l[[input$type1]])[-1])
}),

#2
renderUI({
  req(input$metric1)
  selectInput("type2", label = "metric 2 type:",
            choices = metric_types)
}),

renderUI({
  req(input$type2)
  selectInput('metric2', 'metric 2:', choices=colnames(metrics.list.react$l[[input$type2]])[-1])
}),

#3

renderUI({
  req(input$metric2)
  selectInput("type3", label = "metric 3 type:",
            choices = metric_types)
}),

renderUI({
  req(input$type3)
  selectInput('metric3', 'metric 3:', choices=colnames(metrics.list.react$l[[input$type3]])[-1])
}),

#4

renderUI({
  req(input$metric3)
  selectInput("type4", label = "metric 4 type:",
            choices = metric_types)
}),

renderUI({
  req(input$type4)
  selectInput('metric4', 'metric 4:', choices=colnames(metrics.list.react$l[[input$type4]])[-1])
}),

#5

renderUI({
  req(input$metric4)
  selectInput("type5", label = "metric 5 type:",
            choices = metric_types)
}),

renderUI({
  req(input$type5)
  selectInput('metric5', 'metric 5:', choices=colnames(metrics.list.react$l[[input$type5]])[-1])
}),

# 6

renderUI({
  req(input$metric5)
  selectInput("type6", label = "metric 6 type:",
            choices = metric_types)  
}),

renderUI({
  req(input$type6)
  selectInput('metric6', 'metric 6:', choices=colnames(metrics.list.react$l[[input$type6]])[-1])
}),

#7 
renderUI({
  req(input$metric6)
  selectInput("type7", label = "metric 7 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type7)
  selectInput('metric7', 'metric 7:', choices=colnames(metrics.list.react$l[[input$type7]])[-1])
}),

#8
renderUI({
  req(input$metric7)
  selectInput("type8", label = "metric 8 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type8)
  selectInput('metric8', 'metric 8:', choices=colnames(metrics.list.react$l[[input$type8]])[-1])
}),
#9
renderUI({
  req(input$metric8)
  selectInput("type9", label = "metric 9 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type9)
  selectInput('metric9', 'metric 9:', choices=colnames(metrics.list.react$l[[input$type9]])[-1])
}),

#10
renderUI({
  req(input$metric9)
  selectInput("type10", label = "metric 10 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type10)
  selectInput('metric10', 'metric 10:', choices=colnames(metrics.list.react$l[[input$type10]])[-1])
}),
#11
renderUI({
  req(input$metric10)
  selectInput("type11", label = "metric 11 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type11)
  selectInput('metric11', 'metric 11:', choices=colnames(metrics.list.react$l[[input$type11]])[-1])
}),

#12
renderUI({
  req(input$metric11)
  selectInput("type12", label = "metric 12 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type12)
  selectInput('metric12', 'metric 12:', choices=colnames(metrics.list.react$l[[input$type12]])[-1])
}),



actionButton('apply', 'apply selected metrics'),


width=190, label='select metrics', circle = F
  
  
)

div(style="margin-bottom:5px") # adds padding between buttons


############# filter selection dropdown

custom_options=reactive({
  cols=colnames(prep_custom.df()) # -1 to remove ID as option
  cols=cols[which(startsWith(cols, pattern='X')==FALSE)]
  all=c('None', cols)
  all
  })

h3('Local filters')
dropdownButton(label='manual filters', circle = F, width = 190,
               
renderUI({
  req(input$apply)
  selectInput("VarCustom1", label = "Filter 1:",
            choices = custom_options(), selected = 'None')
}),

renderUI({
    req(input$apply)
    selectInput("IneqCustom1", label = "Inequality 1:",
            choices = c('<', '>'), selected = '<')
}),

renderUI({
  req(input$apply)
  textInput('ThreshCustom1', label= 'Threshold 1:', value='', placeholder='10')

}),

renderUI({
  req(input$apply)
  selectInput("VarCustom2", label = "Filter 2:",
            choices = custom_options(), selected = 'None')
}),

renderUI({
      req(input$apply)
    selectInput("IneqCustom2", label = "Inequality 2:",
            choices = c('<', '>'), selected = '<')
  
}),

renderUI({
    req(input$apply)
  textInput('ThreshCustom2', label= 'Threshold 2:', value='', placeholder='10')

}),

renderUI({
  req(input$apply)
  selectInput("VarCustom3", label = "Filter 3:",
            choices = custom_options(), selected = 'None')
}),

renderUI({
      req(input$apply)
    selectInput("IneqCustom3", label = "Inequality 3:",
            choices = c('<', '>'), selected = '<')
  
}),

renderUI({
    req(input$apply)
  textInput('ThreshCustom3', label= 'Threshold 3:', value='', placeholder='10')

}),

renderUI({
  req(input$apply)
  textInput("IDCustom", label='Select policy IDs', placeholder='eg: 292,54')
})

)


div(style="margin-bottom:20px") # adds padding between buttons
renderUI({
  req(input$apply)
  actionButton('manualfilterCustom', 'save manual filters', width = 190)
})

div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(input$apply)
  actionButton('brushfilterCustom',label='save brush filters', width = 190)

})

h4("table selections:", align="center")

renderUI({
  req(name$n)
  
  fluidRow(column(width=3,
    actionButton('tableKeepCustom',label='keep', width=91)),
    column(width=3, offset=2,
    actionButton("tableRemoveCustom", label="remove", width=93))
    )

})

div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(input$apply)
  actionButton('localresetCustom',label='reset local filters', width = 190)

})
div(style="margin-bottom:20px") # adds padding between buttons

h3('Global filters')

renderUI({
  req(input$apply)
  actionButton('global_filterCustom', label='save filters globally', width = 190)
})
div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(input$apply)
  actionButton('resetCustom',label='reset global filters', width = 190)
})

div(style="margin-bottom:5px") # adds padding between buttons

h3('Plot variables')

renderUI({
  req(input$apply)
  actionButton('addFront', label='Calculate fronts', width = 190)
})

div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(input$apply)
  selectInput('colorCustom', label='ParCoords color variable', choices=c(custom_options()[-1], 'global.filter', 'front'), selected = custom_options()[1], width = 190)

})

renderUI({
  req(input$apply)
  selectInput('xAxisCustom', label = 'Metric for ranking', choices=custom_options()[-1], selected=custom_options()[1], width = 190)
})


downloadButton("download_Custom",label="Download filtered policies")


downloadHandler(filename="Custom filtered policies.xlsx", content=function(file) {

  # remove empty rows in the log objects
  data=filterLog$global
  global=data[rowSums(is.na(data)) != ncol(data),]
  data=logCustom$log
  local=data[rowSums(is.na(data)) != ncol(data),]

  temp=select(filter.Custom(), -starts_with("X"))
  cat(file=stderr(), 'your name:', colnames(temp), "\n") # prints dimension to R console
  df=dplyr::filter(temp, ID %in% KS$index)
  
  
  data.list=list("policies"=df, "global.filters"=global, "local.filters"=local)
  write.xlsx(data.list, file)
  
})

div(style="margin-bottom:50px") # adds padding between buttons

fluidRow(column(12, div(circleButton(inputId= "settingsCustom", icon=icon("chart-line"), status = "primary")
, style="float: right")))
bsTooltip(id="settingsCustom",title="global plot settings", options=list(container="body"), placement = "left")

observeEvent(input$settingsCustom, {modalTrigger$Custom=1+modalTrigger$Custom}, ignoreInit = T)


```


```{r, process Custom UI, include=FALSE}

# create custom dataframe
prep_custom.df=eventReactive(eventExpr={input$apply| input$addFront | reset$SOWchange > 0},{
  

  for (i in 1:13){ # loop through user input, determine number of metrics
    if (!isTruthy(input[[paste0('metric',(i))]])){
      break
    }
    cols=i+1
  }

  df=data.frame(matrix(nrow=nrow(wide_data), ncol=cols))
  df[,1]=wide_data$ID
  colnames(df)[1]='ID'
  for(i in 2:13){
    
    if (isTruthy(input[[paste0('metric',(i-1))]])){ # have to check if input was given. If not, error!
        
        type=input[[paste0('type',(i-1))]] # metric type (ie, regret2, LaplacePIR)
        name=input[[paste0('metric',(i-1))]] # metric name
        df[,i]=metrics.list.react$l[[type]][[name]]

        if (name %in% colnames(df)){ # check if column name alread exists
          colnames(df)[i]=paste(type,'.',name, sep='')
          first_i=which(colnames(df) == name)
          colnames(df)[first_i]=paste(input[[paste0('type',first_i-1)]], '.', name, sep='')
        } else { # I opted to label every axis with type.metric, even if metric not already used. Simpler this way
          colnames(df)[i]=paste(type,'.',name, sep = '')
        }
          
    }
    
    df=data.frame(df[,1:cols], add_to_tradeoff)
  }
  reset$SOWchange=0
  
  df
}, ignoreNULL = T, ignoreInit = T)


custom.df=reactive({dplyr::filter(prep_custom.df(), ID %in% global_filter$r)})

#### initialize with all 463 policies
policiesIDCustom=reactiveValues(r=1:nrow(wide_data))
manualIDCustom=reactiveValues(r=1:nrow(wide_data))
interactiveIDCustom=reactiveValues(r=1:nrow(wide_data))

logCustom=reactiveValues(log=df.initialize)

#### calculate non dominated front on user input ####

front.Custom=reactiveValues(f=rep(1,nrow(wide_data))) # initialize as ones

observeEvent(input$addFront,{
  
  withProgress(message='Calculating fronts', value=0, {
      front.Custom$f=calc_NonDom_front(data=prep_custom.df()[,1:nvar()], max_cols = max_id())
      incProgress(amount=0.75)
  })
  
}, priority = 100)


#### update manualIDCustom based on user input

observeEvent(input$manualfilterCustom, {
  temp=manual_filters(ID_key='IDCustom', unique_thresh_ID = 'Custom',dataframe = custom.df(), page="Custom")
  manualIDCustom$r=temp[[1]]
  
  logCustom$log=rbind(logCustom$log, temp[[2]])
})

#### update interactiveIDCustom based on par coords brushing
rangesCustom <- reactiveValues(a=list())
#### get ranges from brushing

observeEvent(eventExpr = event_data("plotly_restyle", source = "pcoordsCustom"),{

  df=data.frame(prep_custom.df()[,1:nvar()],front=front.Custom$f)

  temp=get_brush_ranges(source = "pcoordsCustom", prep_df = df)
    if (is.na(temp)){
    # do nothing
  } else {
     rangesCustom$a[[temp[[1]]]]=temp[[2]]
     
  }
  
})

#### get policies from brushing
observeEvent(input$brushfilterCustom,{

  
  df=data.frame(prep_custom.df()[,1:nvar()],front=front.Custom$f)

  temp=get_brush_policyID(ranges=rangesCustom$a, prep_df = df, page="Custom")
  
  interactiveIDCustom$r=temp[[1]]
   
  logCustom$log=rbind(logCustom$log, temp[[2]])
})

### update policiesIDCustom as intersection of global filter, manual filter, and interactive filter

observe({
  a=intersect(manualIDCustom$r, interactiveIDCustom$r)
  b=intersect(a, global_filter$r)
  policiesIDCustom$r=b
}
)

### update policiesIDCustom based on table selections

observeEvent(input$tableKeepCustom, {
  
  policiesIDCustom$r=intersect(policiesIDCustom$r, tableSelectCustom$id)
  
  add_vec=c("Custom", "ID", "table select", NA, NA, paste(as.character(tableSelectCustom$id), collapse=","))
  temp=df.initialize
  temp[1,]=add_vec
  logCustom$log=rbind(logCustom$log, temp)
  
}, ignoreInit = T)

observeEvent(input$tableRemoveCustom, {
  
  all=1:nrow(wide_data)
  subset=all[-tableSelectCustom$id]
  
  policiesIDCustom$r=intersect(policiesIDCustom$r, subset)
  
  add_vec=c("Custom", "ID", "table remove", NA, NA, paste(as.character(tableSelectCustom$id), collapse=","))
  temp=df.initialize
  temp[1,]=add_vec
  logCustom$log=rbind(logCustom$log, temp)
  
}, ignoreInit = T)

### establish filter.custom

filter.Custom=reactive({ # because Custom() already accounts for global filter, filter.Custom is intersection of global and local POLICY ID filter only
  validate(need(input$apply, 'Select robustness metrics'))
  dplyr::filter(custom.df(), ID %in% policiesIDCustom$r)
  
})

### apply global filter

observeEvent(input$global_filterCustom, {
  
  temp=intersect(policiesIDCustom$r, KS$index)
  global_filter$r=intersect(global_filter$r, temp )
  
  remaining=length(global_filter$r)
  showNotification(paste(remaining, 'policies remain in global filter', sep=' ' ), type='message', duration=7)
  
  filterLog$global=rbind(filterLog$global, logCustom$log)
})


### local reset button

observeEvent(input$localresetCustom, {
  policiesIDCustom$r=1:nrow(wide_data)
  manualIDCustom$r=1:nrow(wide_data)
  interactiveIDCustom$r=1:nrow(wide_data)
  tableSelectCustom$id=NULL
  rangesCustom$a=NULL
  logCustom$log=df.initialize
})

# also, if color changes, reset local filters

observeEvent(input$colorCustom,{

  interactiveIDCustom$r=1:nrow(wide_data)
  rangesCustom$a=NULL
  
  rows=which(logCustom$log$filter.type=="brush")
  logCustom$log=logCustom$log[-rows,]
})



```

Row {data-height=325}
-----------------------
### Parallel coordinates

```{r, custom parallel coordinates}

includeFront=reactiveValues(Bin=0)

observeEvent(input$addFront, { # indicate of front axis is added to PC plot
  includeFront$Bin=1
})

observeEvent(reset$SOWchange>0, { # remove front from PC if SOW ensemble changes
  includeFront$Bin=0
})

observeEvent(input$apply, { # remove front form PC if user changes PC plot dimensions
  includeFront$Bin=0
})

nvar=reactive({
  
  for (i in 1:13){ # loop through user input, determine number of metrics
    if (!isTruthy(input[[paste0('metric',(i))]])){
      break
    }
    cols=i+1
    }
  cols
})

max_id=reactive({
  which(startsWith(colnames(prep_custom.df()), 'satisficing.satisficing')==TRUE)
})


plotlyOutput("pcCustom")

color_custom=reactiveValues() #initiate container for custom color variables initiation

output$pcCustom=renderPlotly({
  
  input$KeepPoliciesTF # this causes plot to rerender if user changes options from keeping filtered policies to removing them or vise versa
  
  validate(need(input$apply, 'Select robustness metrics'))
  isTruthy(input$localresetCustom)

  
  
  # silent error occurs if I don't provide a default value for color_var. This happens because ParCoords Col Var hasn't initiated until filter policies is opened
  
  if (isTruthy(input$colorCustom)){
    color_custom$c=input$colorCustom
  } else {
    color_custom$c="ID"
  }
  
  

    ## create matrix of policy ID constraints that considers both the global filter plus table selections
  bind=rbind(tableSelectCustom$constraints, global_filter$constraints) # bind table and global filter matrices
  
  if(TRUE %in% duplicated(bind)){ # check if any duplicate rows. If so, then the user has selected data in the table and only that should be highlighted
    ID_constraints=bind[duplicated(bind),]
  } else {
    ID_constraints=global_filter$constraints # if no duplicates, then color only policies in global filter
  }

  

  if (includeFront$Bin>0){
    
    axes_data=data.frame(prep_custom.df()[,1:nvar()],front=front.Custom$f, prep_custom.df()[,(nvar()+1):ncol(prep_custom.df())] ,global.filter=in_global_filter$y)
    
    if (input$KeepPoliciesTF==TRUE){
    temp=data.frame(prep_custom.df()[,1:nvar()],front=front.Custom$f, prep_custom.df()[,(nvar()+1):ncol(prep_custom.df())] ,global.filter=in_global_filter$y)
    data=dplyr::filter(temp, ID %in% KS$index)
    } else if (input$KeepPoliciesTF==FALSE){
    temp=data.frame(filter.Custom()[,1:nvar()],front=front.Custom$f[filter.Custom()[['ID']]], filter.Custom()[,(nvar()+1):ncol(filter.Custom())])
    data=dplyr::filter(temp, ID %in% KS$index)
    } else {
    temp=data.frame(prep_custom.df()[,1:nvar()],front=front.Custom$f, prep_custom.df()[,(nvar()+1):ncol(prep_custom.df())] ,global.filter=in_global_filter$y)
    data=dplyr::filter(temp, ID %in% KS$index)
    }
    
    
          custom=par_coords(data=data, n_var=nvar()+1, color_var = color_custom$c, title='user selected metrics', max_cols = max_id(), source='pcoordsCustom', policy_ID = ID_constraints, colorbarTitle = color_custom$c, axes_data=axes_data)


  } else {
    
    axes_data=data.frame(prep_custom.df(),global.filter=in_global_filter$y)
    
      if (input$KeepPoliciesTF==TRUE){
    temp=data.frame(prep_custom.df(),global.filter=in_global_filter$y)
    data=dplyr::filter(temp, ID %in% KS$index)
    } else if (input$KeepPoliciesTF==FALSE){
    data=dplyr::filter(filter.Custom(), ID %in% KS$index)
    } else {
    temp=data.frame(prep_custom.df(),global.filter=in_global_filter$y)
    data=dplyr::filter(temp, ID %in% KS$index)
    }
    # colnames=colnames(data)
    # n_var=nvar()
    # cat(file=stderr(), 'custom columns:', colnames, "\n") # prints dimension to R console
    # 
    custom=par_coords(data=data, n_var=nvar(), color_var = color_custom$c, title='user selected metrics', max_cols = max_id(),
             source='pcoordsCustom', policy_ID = ID_constraints, colorbarTitle = color_custom$c, axes_data=axes_data)
  }
  

  custom=event_register(custom, "plotly_restyle")
  custom
  
})

```

Row {.tabset .tabset-fade data-height=275}
-------------------------------------------

### Rank of filtered policies for selected metric

```{r, Custom DV plot}

min_or_max_cust=reactive({
  
  if (startsWith(input$xAxisCustom, 'satisficing.satisficing')){
    'max'
  }else {
    'min'
  }
  
})

renderPlotly({
  req(input$xAxisCustom) # removes temporary error message caused by input$xAxisCustom not rendering until input$apply
  DV_plot(metric=prep_custom.df(), to_plot = intersect(filter.Custom()[["ID"]], KS$index) , preferred_direction = min_or_max_cust(),
          metric_label = input$xAxisCustom)
  
})

# 

```

### Table of filtered policies

```{r, Custom table}

output$Custom_data <- DT::renderDataTable({
  input$localresetCustom
  temp=select(filter.Custom(), -starts_with("X"))
  dplyr::filter(temp, ID %in% KS$index)
}, options = list(scrollY="245px", scrollX="100px", pageLength=10), rownames=FALSE
)

DT::dataTableOutput("Custom_data")

tableSelectCustom=reactiveValues(id=NULL)

observe({
  
  data=dplyr::filter(filter.Explore(), ID %in% KS$index)

  tableSelectCustom$id=data[['ID']][input$Custom_data_rows_selected]
  a=tableSelectCustom$id-.001
  b=tableSelectCustom$id+.001
  tableSelectCustom$constraints=matrix(c(a,b),ncol=2, byrow = FALSE)

})

```


Rank correlation{data-orientation=rows}
========================================

Column{.sidebar data-width=225}
--------------------------------

```{r, rank cor UI}
h3("x axis")

selectInput('SOW1x', label='SOW ensemble', selected='cLHS n500', choices=c('cLHS n500', 'cLHS n300'))


SOW=reactiveValues()
observeEvent(input$SOW1x,{
  SOW$x=if(input$SOW1x=='cLHS n500'){metrics.list_n500} else if (input$SOW1x=='cLHS n300'){metrics.list_n300} else {metrics.list_n500}
})

renderUI({

  req(input$SOW1x)

  selectInput('CorTypex','metric type', choices=names(SOW$x), selected=names(SOW$x)[1])

})


h3("y axis")

selectInput('SOW1y', label='SOW ensemble', selected='cLHS n300', choices=c('cLHS n500', 'cLHS n300'))

observeEvent(input$SOW1y,{
  SOW$y=if(input$SOW1y=='cLHS n500'){metrics.list_n500} else if (input$SOW1y=='cLHS n300'){metrics.list_n300} else {metrics.list_n500}
})

renderUI({

  req(input$SOW1y)
  selectInput('CorTypey','metric type', choices=names(SOW$y), selected=names(SOW$y)[1])

})


```

Row {.tabset .tabset-fade}
-----------------------------------------

### SOW ensemble correlation

```{r}

library(Kendall)

rankCor=reactive({

  req(input$CorTypex)
  req(input$CorTypey)

  
  x=SOW$x[[input$CorTypex]][-1]
  y=SOW$y[[input$CorTypey]][-1]

  x_rank=data.frame(matrix(nrow=nrow(x), ncol=ncol(x)))
  colnames(x_rank)=colnames(x)

  for(i in 1:ncol(x)){
    correction=ifelse(startsWith(colnames(x)[i], 'satisficing'),-1,1)
    x_rank[,i]=rank(correction*x[,i])
  
  }

  y_rank=data.frame(matrix(nrow=nrow(y), ncol=ncol(y)))
  colnames(y_rank)=colnames(y)

  for(i in 1:ncol(y)){
   correction=ifelse(startsWith(colnames(y)[i], 'satisficing'),-1,1)
   y_rank[,i]=rank(correction*y[,i])
    
  }


  cor.df=data.frame(matrix(nrow=ncol(x)*ncol(y), ncol=3))
  colnames(cor.df)=c('x', 'y', 'rank.cor')

  c=1
  for (yi in 1:ncol(y)){# loop through y variables
  
    y_temp=y_rank[,yi]
  
    for (xi in 1:ncol(x)){# loop through x variables
    
      x_temp=x_rank[,xi]
    
    # cor=Kendall(x,y)$tau
    
      cor.df$y[c]=colnames(y_rank)[yi]
      cor.df$x[c]=colnames(x_rank)[xi]
      cor.df$rank.cor[c]=Kendall(x_temp,y_temp)$tau
    
      c=c+1
    
    }
  
  }
  cor.df
})

renderPlotly({
  
  req(nrow(rankCor())>0)
  
  x=rankCor()[['x']]
  y=rankCor()[['y']]
  z=rankCor()[["rank.cor"]]

  axis=function(name){
    return(list(title=name))
  }
  
  fig=plot_ly(type='heatmap', colorscale = "Portland",
             
             x=x, y=y, z=z, xgap=3, ygap=3
             
             
  ) %>% layout(xaxis=axis(input$SOW1x), yaxis=axis(input$SOW1y), title='Kendall Tau rank correlation', margin=list(l=50,r=40,b=60,t=40,   pad=0))

  fig=colorbar(fig, limits=c(-1.05,1.05))
  fig
  
})


```

### Mead.1000 & Powell.3490 satisficing thresholds

```{r, satisficing plotting sensitivity setup}

plot.df=read.table('Mead1000_Powell3490_ThreshSensitivity_results.txt')
plot.df2=read.table('LBSV_Mead1000_Powell3490_ThreshSensitivity_results.txt')

# note that this sensitivity analysis was performed with cLHS n500 ensemble, not cLHS n300
# see Function libary.R for font style and functions to return title list and axes lists

```

```{r, Mead and Powell heat maps}

renderPlotly({
  
  x='Powell.3490'
  y='Mead.1000'
  z='correlation'
  
  fig1=plot_ly(type='heatmap',
               x=plot.df[[x]], y=plot.df[[y]], z=plot.df[[z]]
  ) %>% layout(xaxis=xaxis(""), yaxis=axis(y), annotations=subplotTitle('Rank correlation'), margin=list(l=50,r=40,b=60,t=40, pad=0)) %>% colorbar(x=.45, y=1)
  
  
  x='Powell.3490'
  y='Mead.1000'
  z='delta.mean'
  
  fig2=plot_ly(type='heatmap', colors="PuOr",
               x=plot.df[[x]], y=plot.df[[y]], z=plot.df[[z]]
  ) %>% layout(xaxis=axis(x), yaxis=xaxis(""), annotations=subplotTitle('Change in average satisficing'), margin=list(l=50,r=40,b=60,t=40, pad=0))
  
  lim=max(abs(range(plot.df$delta.mean)))+.05
  
  fig2=colorbar(fig2, limits=c(-lim, lim), x=1,y=1)

  x='Powell.3490'
  y='Mead.1000'
  z='mean'
  
  fig3=plot_ly(type='heatmap',
               x=plot.df[[x]], y=plot.df[[y]], z=plot.df[[z]]
  ) %>% layout(xaxis=axis(x), yaxis=axis(y), annotations=subplotTitle('Average satisficing'), margin=list(l=50,r=40,b=60,t=40, pad=0)) %>% colorbar(x=.45, y=.45)
  
  subplot(fig1,fig2,fig3, titleX = T, titleY=T, nrows = 2, margin = .05)
  
  
})

```

### LBSV & Reservoirs satisficing thresholds

```{r, LBSV and Reservoir heat maps}
renderPlotly({
  
  x='Res.Thresh.Dif'
  y='LBSV'
  z='correlation'
  
  fig4=plot_ly(type='heatmap',
               
               x=plot.df2[[x]], y=plot.df2[[y]], z=plot.df2[[z]]
               
               
  ) %>% layout(xaxis=xaxis(""), yaxis=axis(y), annotations=subplotTitle('Rank correlation'), margin=list(l=100,r=40,b=100,t=40, pad=0)) %>% colorbar(x=.45, y=1)
  
  x='Res.Thresh.Dif'
  y='LBSV'
  z='delta.mean'
  
  fig5=plot_ly(type='heatmap', colors='PuOr',
               
               x=plot.df2[[x]], y=plot.df2[[y]], z=plot.df2[[z]]
               
               
  ) %>% layout(xaxis=xaxis(), yaxis=xaxis(""), annotations=subplotTitle('Change in average satisficing'), margin=list(l=50,r=40,b=100,t=40, pad=0))
  
  lim=max(abs(range(plot.df2$delta.mean)))+.05
  
  fig5=colorbar(fig5, limits=c(-lim, lim),x=1, y=1)
  
  x='Res.Thresh.Dif'
  y='LBSV'
  z='mean'
  
  fig6=plot_ly(type='heatmap',
               
               x=plot.df2[[x]], y=plot.df2[[y]], z=plot.df2[[z]]
               
               
  ) %>% layout(xaxis=xaxis(), yaxis=axis(y), annotations=subplotTitle('Average satisficing'), margin=list(l=50,r=40,b=60,t=40, pad=0))%>% colorbar(x=.45, y=.45)
  
  
  subplot(fig4,fig5,fig6, titleX = T, titleY=T, nrows=2, margin = .05) 
})

```
