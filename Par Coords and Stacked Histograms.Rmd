---
title: "CRB robustness tradeoffs"
output: 
  flexdashboard::flex_dashboard:
    navbar:
        - {icon: "fa-user-cog", href: "#section-settings", align: right}
    source_code: "https://github.com/nabocrb/CRB-robustness-app"
    
runtime: shiny
---

```{r, include=FALSE}
# load data in 'global' chunk so it can be shared by all users of the dashboard
library(knitr)
library(flexdashboard)
library(dplyr)
library(plotly) # one method for par coords. Not super happy: no tooltips
library(shiny)
library(shinyWidgets)
library(stringr)
library(gdata) #startsWith
library(nsga2R)
library(DT) # for sortable data table
library(openxlsx)
# library(shinycssloaders) # for 'waiting' icon


################### import robustness metrics ###################

# for code development, I am just using metrics.df from 'Robustness calcs for Kennard Stone.R'

# this includes the non dominated front. Calculated externally to save app loading time
metrics_4app=readRDS('tradeoff_dataframes.rds')

# scale mean_variance between 0 and 1

colID=which(!(colnames(metrics_4app[['mean.variance']]) %in% c('policy', 'front')))

for(i in colID){ # start in column three to skip ID and front
  max=max(metrics_4app$mean.variance[,i])
  replace=metrics_4app$mean.variance[,i]/max
  
  metrics_4app$mean.variance[,i]=replace
}

# used for x axis in stacked histogram plot
metrics.list=readRDS('Robustness_metrics_463solns_List.rds')
metrics.list[['baseline']]=metrics_4app$baseline


################### import data for stacked histogram plotting ##########################

bar_plot_data=readRDS(file='data for stacked bar plot.rds')
long_data=bar_plot_data$long_data
wide_data=bar_plot_data$wide_data
wide_data$policy=1:nrow(wide_data)

add_to_tradeoff_all=wide_data[4:8] # T1e, T1V, maxVol, nTiers to add to each df for filtering
add_to_tradeoff=dplyr::filter(add_to_tradeoff_all, policy %in% metrics.list$satisficing$policy)[-ncol(add_to_tradeoff_all)]# minus five to remove policy

############## import DV so user can add to custom parallel coordinates #########
DV_prep=read.table('Archive_463_Condensed.txt')
DV=data.frame(policy=wide_data$policy, DV_prep, ntiers=add_to_tradeoff$nTiers, maxVol=add_to_tradeoff$maxVol)
metrics.list[['DV']]=DV
metrics_4app[['DV']]=DV
###################### prepare robustness data frames ##################
########################################################################

global_filter=reactiveValues(r=1:463) # Initiate with all policies. changes whenever a user hits save button.
in_global_filter=reactiveValues(y=rep(1,nrow(wide_data)))
atLeast13=data.frame(matrix(nrow=nrow(wide_data), ncol=13)) # need this data frame to add to the tradeoff dfs so par_coords data has at least 13 columns

###### baseline performance (in MOEA optimization)
prep_baseline=data.frame(metrics_4app$baseline, add_to_tradeoff, atLeast13)
baseline_all=reactive({prep_baseline})
baseline=reactive({dplyr::filter(prep_baseline, policy %in% global_filter$r)})

###### LBSV < 600 KAF, Mead 1000 < 10% and Powell 3490 < 5%#####
prep_satisficing=data.frame(metrics_4app$satisficing, add_to_tradeoff, atLeast13)
# satisficing=reactive({dplyr::filter(prep_satisficing, policy %in% global_filter$r)})

##### % deviation
prep_percent_deviation=data.frame(metrics_4app$percent.deviation, add_to_tradeoff, atLeast13)
# percent_deviation_tradeoffs=reactive({dplyr::filter(prep_percent_deviation, policy %in% global_filter$r)})

#### tradeoff between mean of objectives (Laplace PIR)
prep_Laplace=data.frame(metrics_4app$Laplaces.PIR, add_to_tradeoff, atLeast13)
# LaplaceTradeOff=reactive({dplyr::filter(prep_LaplaceTradeOff, policy %in% global_filter$r)})

#### tradeoff between mean-variance

prep_mean_var=data.frame(metrics_4app$mean.variance, add_to_tradeoff, atLeast13)
# mean_var_tradeoff=reactive({dplyr::filter(prep_mean_var_tradeoff, policy %in% global_filter$r)})

### regret from best tradeoffs
prep_regret2=data.frame(metrics_4app$regret.from.best, add_to_tradeoff, atLeast13)
# regret2_tradeoff=reactive({dplyr::filter(prep_regret2, policy %in% global_filter$r)})

#### tradeoffs between Hurwicz OP
prep_Hurwicz=data.frame(metrics_4app$Hurwicz.OP, add_to_tradeoff, atLeast13)
# Hurwicz_tradeoff=reactive({dplyr::filter(prep_Hurwicz_tradeoff, policy %in% global_filter$r)})

#### maximin (worst case SOW) tradeoffs
prep_maximin=data.frame(metrics_4app$maximin, add_to_tradeoff, atLeast13)
# maximin_tradeoff=reactive({dplyr::filter(prep_maximin_tradeoff, policy %in% global_filter$r)})

###### prepare reactiveValue global filters log object ######

df.initialize=data.frame(matrix(ncol=6, nrow=1))
colnames(df.initialize)=c("page", "metric", "filter.type", "lower", "upper", "table.selection.ID")

filterLog=reactiveValues(global=df.initialize, local=df.initialize)


```

```{r, functions, include=FALSE}

#################### functions #################################
################################################################

############## parallel coordinates plotting function

par_coords=function(data, n_var, max_cols=NULL, color_var, title='User selected metrics', labels=colnames(data), source=NULL, policy_ID=NULL, color_scale=input$ColorScale, reverse_scale=input$ReverseTF){
  
  legendx=1.04
  legendy=.5
  legendtitle <-  list(yref='paper',xref="paper",y=legendy,x=legendx, text='selected variable',showarrow=F, textangle=90, size=12, colour='darkgrey') # size isn't doing anything
  
  T_F=rep(FALSE,13)
  
  if (is.null(max_cols)){
   
  } else {
    
    T_F[max_cols]=TRUE
    
  }
  
  # Viridis, Rainbow, Picnic
  mypal=matrix(nrow=4, ncol=2)
  mypal[,1]=c(0,.25,.75,1)
  mypal[,2]=c('rgb(255,0,0)','rgb(255,102,255)','rgb(153,255,255)','rgb(0,0,255)')
  
  if (color_scale=='blue-red'){color_scale=mypal}
  
  p <-data %>% plot_ly(type = 'parcoords', tickfont=list(size=13),
                                               line = list(color =data[[color_var]], #colorbar=list(title='test'),
                                                           colorscale = color_scale, reversescale=reverse_scale, showscale=TRUE),
                                               dimensions = list(
                                                 list(range = sort(range(data[[1]]), decreasing=T_F[1]),label = labels[1], values = data[[1]], constraintrange=policy_ID), 
                                                 list(range = sort(range(data[[2]]), decreasing=T_F[2]),label = labels[2], values = data[[2]]),
                                                 list(range = sort(range(data[[3]]), decreasing=T_F[3]),label = labels[3], values = data[[3]]),
                                                 list(range = sort(range(data[[4]]), decreasing=T_F[4]),label = labels[4], values = data[[4]]),
                                                 list(range = sort(range(data[[5]]), decreasing=T_F[5]),label = labels[5], values = data[[5]]),
                                                 list(range = sort(range(data[[6]]), decreasing=T_F[6]),label = labels[6], values = data[[6]]),
                                                 list(range = sort(range(data[[7]]), decreasing=T_F[7]),label = labels[7], values = data[[7]]),
                                                 list(range = sort(range(data[[8]]), decreasing=T_F[8]),label = labels[8], values = data[[8]]),
                                                 list(range = sort(range(data[[9]]), decreasing=T_F[9]),label = labels[9], values = data[[9]]),
                                                 list(range = sort(range(data[[10]]), decreasing=T_F[10]),label = labels[10], values = data[[10]]),
                                                 list(range = sort(range(data[[11]]), decreasing=T_F[11]),label = labels[11], values = data[[11]]),
                                                 list(range = sort(range(data[[12]]), decreasing=T_F[12]),label = labels[12], values = data[[12]]),
                                                 list(range = sort(range(data[[13]]), decreasing=T_F[13]),label = labels[13], values = data[[13]])

                                               ), source=source
                                               
  ) # end plot_ly()
  
  # add title and legend annotation
  p=p %>% layout(margin=list(l=40,r=10,b=20,t=0, pad=0), title=title, annotations=legendtitle)
  
  # remove excess axis from the plotly object
  p=plotly_build(p) # building creates the list that you can edit to remove excess axis
  
  for (i in 13:(n_var+1)){
    
    p[["x"]][["data"]][[1]][["dimensions"]][[i]]=NULL
    
    
  }
  
  return(p)
  
  
}


########## stacked histogram DV plotting function

# function to change ggplot legend size: https://stackoverflow.com/questions/52297978/decrease-overal-legend-size-elements-and-text
addSmallLegend <- function(myPlot=bar_plot, pointSize = 0.25, textSize = 8, spaceLegend = 0.03) {
    myPlot +
        guides(shape = guide_legend(override.aes = list(size = pointSize)),
               color = guide_legend(override.aes = list(size = pointSize))) +
        theme(legend.title = element_text(size = textSize), 
              legend.text  = element_text(size = textSize),
              legend.key.size = unit(spaceLegend, "lines"))
}

DV_plot=function(long.data=long_data, wide.data=wide_data, metric= robustness_metrics$satisficing,
                 to_plot=robustness_metrics$satisficing$policy, metric_label='satisficing', preferred_direction='max'){
  
  # filter for chosen policies
  filter.long=dplyr::filter(long.data, policy %in% to_plot)
  filter.wide=dplyr::filter(wide.data, policy %in% to_plot)
  filter.metric=dplyr::filter(metric, policy %in% to_plot)
  
  # get rank, append to data frames
  
  correction=ifelse(preferred_direction == 'min', 1, -1) # to handle metrics that should be minimized and maximizied accordingly in the ranking
  decreasing=ifelse(preferred_direction == 'min', F, T) # needed for add_lines in plot function
  
  filter.metric$rank=rank(correction*filter.metric[[metric_label]], ties.method = 'first')
  filter.long$rank=rep(filter.metric$rank, each=length(unique(filter.long$Tier)))
  filter.wide$rank=filter.metric$rank
  
  
  ############################# plotting ################################
  text_size=2.7
  
  n_policies=nrow(filter.wide)
  
  bar_plot=ggplot(mapping=aes(label1=policy))+
    geom_bar(data=filter.long, aes(fill=Tier, x=rank, y=delta), position = 'stack', stat = 'identity', color='darkgrey')+
    geom_text(data=filter.long, aes(x=rank, y= elevation, label=v_lab),color='black', nudge_y = -4, size=text_size, check_overlap = T)+
    geom_text(data=filter.wide, aes(x=rank, y= policy_lab_y, label=policy_lab), nudge_y = 4, size=text_size, check_overlap = T)+
    # geom_text(data=filter.wide, aes(x=rank, y= policy_lab_y, label=SOM_node), nudge_y = 10, size=text_size, check_overlap = T)+ I have removed SOM node for NOW
    scale_fill_brewer(palette='RdYlBu', direction = -1)+
    xlab(paste(metric_label, 'rank', sep=' '))+
    ylab('pool elevation [ft msl]')+
    theme(plot.title = element_text(size=10), plot.margin=margin(t=0, r=0, b=0, l=0, unit='pt'))+
    coord_cartesian(ylim=c(895,1110), xlim=c(1, min((n_policies+1),20)))
  
  bar_plot=addSmallLegend(bar_plot)
  # ggtitle(paste(metric_label, 'rank for selected policies', sep=' '))+
  
  int_plot=ggplotly(p=bar_plot, tooltip = c('policy', 'rank','elevation', 'volume')) # convert ggplot to interactive plotly html
  
  int_plot_2y=int_plot %>%
    add_lines(data=filter.metric, x=~sort(filter.metric$rank), y=~sort(filter.metric[[metric_label]], decreasing = decreasing), yaxis='y2',
              inherit=FALSE, showlegend=FALSE, line=list(color='purple', width=2, dash='dash')) %>%
    layout(yaxis2 = list(overlaying = "y", side = "right",
                         tickfont = list(color = 'purple', size=10), color = 'purple',
                         title = metric_label),
           legend = list(x = 1.05, y = 0.95))
  
  return(int_plot_2y)
  
  
  
}

calc_NonDom_front=function(data, policy_ID_column=1, max_cols=NULL){
  
  front=rep(NA, nrow(data))
  
  if(is.null(max_cols)==FALSE){ # fastNonDOminatedSorting assumes minimization. Multiply be negative 1 for metrics that should be maximized
    
    data[,max_cols]=data[,max_cols]*-1
    
  }
  
  front_list=fastNonDominatedSorting(data[-policy_ID_column])
  
  nfronts=length(front_list)
  
  for (i in 1:nfronts){
    
    policies=front_list[[i]]
    front[policies]=i
    
  }
  

  if(is.null(max_cols)==FALSE){ # convert back to positive where necessary
    
    data[,max_cols]=data[,max_cols]*-1
    
  }
  
  data=data.frame(front=front, data)

  return(front)
  
}


############################ function to update manual_ID$r

function_df=reactiveValues() # need to initialize the dataframes used in the function
manual_log=reactiveValues() 

manual_filters=function(ID_key, unique_thresh_ID, dataframe, page="baseline"){
  
  # prepare log dataframe
  df.initialize=data.frame(matrix(ncol=6, nrow=1))
  colnames(df.initialize)=c("page", "metric", "filter.type", "lower", "upper", "table.selection.ID")
  manual_log$input=df.initialize

  function_df$r=dataframe
  
  rows=list()
  if (!isTruthy(input[[ID_key]]) ){ # if user DID NOT hand selected policies to view
    
    for (i in 1:3){ # loop through filters
      
      log_vec=vector()
      
      if (input[[paste0('Var',unique_thresh_ID,i)]] == 'None' ){
        rows[[i]]=1:nrow(function_df$r)
      } else  if (input[[paste0('Ineq',unique_thresh_ID,i)]] == '<'){
        rows[[i]]=which(function_df$r[[input[[paste0('Var',unique_thresh_ID,i)]]]] < as.numeric(input[[paste0('Thresh',unique_thresh_ID,i)]]))
        
        log_vec[1:6]=c(page, input[[paste0('Var',unique_thresh_ID,i)]], "manual", "0", input[[paste0('Thresh',unique_thresh_ID,i)]], NA)
        
      } else { # greater than
        rows[[i]]=which(function_df$r[[input[[paste0('Var',unique_thresh_ID,i)]]]] > as.numeric(input[[paste0('Thresh',unique_thresh_ID,i)]]))
        
        log_vec[1:6]=c(page, input[[paste0('Var',unique_thresh_ID,i)]], "manual", input[[paste0('Thresh',unique_thresh_ID,i)]], "+inf", NA)
        
      }
      
      # add log_vec to manual log
      if (length(log_vec)>0){
          manual_log$input=rbind(manual_log$input, log_vec)
      }
      
      
    } # end for
    
    a=intersect(rows[[1]],rows[[2]])
    b=intersect(a, rows[[3]])
    
    ID=function_df$r[['policy']][b]
    log=manual_log$input
   return(list(ID, log))
    # return(ID)
  } else { # user selected specific policies to view
    
    log_vec[1:6]=c(page, "policy", "manual", NA, NA,input[[ID_key]])
    
   if (length(log_vec)>0){
          manual_log$input=rbind(manual_log$input, log_vec)
      }
    ID=unlist(lapply(str_split(input[[ID_key]], ','), as.integer))
    log=manual_log$input
    return(list(ID,log ))
    
  } # end else
  
}

########################### functions to get brush ranges and filter data frame #############

## brush ranges

get_brush_ranges=function(source, prep_df){
  
  d <- event_data("plotly_restyle", source = source)
  # what is the relevant dimension (i.e. variable)?
  dimension <- as.numeric(stringr::str_extract(names(d[[1]]), "[0-9]+"))
  # careful of the indexing in JS (0) versus R (1)!
  
  # code for debugging dimension number. Used this to identify need for if(is.na(dimension)) statement below
  # cat(file=stderr(), 'trying to get index', dimension, "\n") # prints dimension to R console
  
  if (is.na(dimension)){ # d is NA when user changes axis position
    # do nothing
    return(NA)
  } else {
    dimension_name <- names(prep_df)[[dimension + 1]]
    # a given dimension can have multiple selected ranges
    # these will come in as 3D arrays, but a list of vectors 
    # is nicer to work with
    info <- d[[1]][[1]]
    ranges <- if (length(dim(info)) == 3) {
      lapply(seq_len(dim(info)[2]), function(i) info[,i,])
    } else if (is.null(info)){
      # ranges[[dimension_name]]=
      NULL # I added this if statement to handle the case where user deselects an axis range. That returns NULL and throws an error if     not skipped with next
    } else {
      list(as.numeric(info))
    }
    return(list(dimension_name, ranges))  
  }
  
    
}

## get brush policy IDs

brush_log=reactiveValues()

get_brush_policyID=function(ranges, prep_df, page="baseline"){
  
  # initialize brush_log
  df.initialize=data.frame(matrix(ncol=6, nrow=1))
  colnames(df.initialize)=c("page", "metric", "filter.type", "lower", "upper", "table.selection.ID")
  brush_log$log=df.initialize
  
  keep <- TRUE
  for (i in names(ranges)) {
    if(is.null(ranges[[i]])){# I added this if statement to handle the case where user deselects an axis range. That returns NULL and throws an error if not skipped with next
      next
    }
    range_ <- ranges[[i]]
    keep_var <- FALSE
    for (j in seq_along(range_)) {
      rng <- range_[[j]]

      keep_var <- keep_var | dplyr::between(prep_df[[i]], min(rng), max(rng))
      
      add_vec=c(page,i, 'brush', min(rng), max(rng), NA)
      brush_log$log=rbind(brush_log$log, add_vec)
      
    }
    keep <- keep & keep_var
  }
  policyID=prep_df[['policy']][keep]
  return(list(policyID, brush_log$log))
}

############## selectInput options ####################

get_options=function(tradeoff_df){
  a=colnames(metrics_4app[[tradeoff_df]])
  b=colnames(add_to_tradeoff) # use to add to filter option drop down menu
  return(c('None',a,b))
}

############################## parallel coords parameters ##############################
########################################################################################
# position to of legend. Don't mess with this unless you have way too free time
legendx=1.04
legendy=.5
legendtitle <-  list(yref='paper',xref="paper",y=legendy,x=legendx, text='selected variable',showarrow=F, textangle=90, size=12, colour='darkgrey') # size isn't doing anything


```

```{r, global filters and resets, include= FALSE}

### global reset

# to have better control over many action buttons, have the action buttons adjust reactiveValues. Then, use the reactive values to trigger resets. For reference: https://gist.github.com/aagarw30/316a65598b048476819dce76504d154d
reset=reactiveValues(
  Baseline=0,
  Custom=0,
  Explore=0
)

observeEvent(input$resetBaseline, {
  reset$Baseline=reset$Baseline+1
  reset$Custom=0
  reset$Explore=0
}, priority = 0,  ignoreNULL = TRUE, ignoreInit = TRUE)

observeEvent(input$resetCustom, {
  reset$Baseline=0
  reset$Custom=reset$Custom+1
  reset$Explore=0
}, priority = 0,  ignoreNULL = TRUE, ignoreInit = TRUE)

observeEvent(input$resetExplore, {
  reset$Baseline=0
  reset$Custom=0
  reset$Explore=reset$Explore+1
}, priority = 0,  ignoreNULL = TRUE, ignoreInit = TRUE)

observeEvent(eventExpr = {reset$Baseline > 0 | reset$Custom > 0 | reset$Explore > 0},
             {global_filter$r=1:463
             
            showNotification('Global filter is reset', type='message', duration=7)

             
             # Debugging code below
             # cat(file=stderr(), 'global filter$r:', global_filter$r, "\n")
             # cat(file=stderr(), 'input$resetBaseline:', input$resetBaseline, "\n")
             # cat(file=stderr(), 'input$resetCustom:', input$resetCustom, "\n")

             in_global_filter$y=rep(1,nrow(wide_data))
             rangesExplore$a=NULL
             ranges$a=NULL
             rangesCustom$a=NULL
             filterLog$global=df.initialize
             filterLog$local=df.initialize}, priority = 10, ignoreNULL = TRUE, ignoreInit = TRUE)

### global filter column to add to data frames for coloring par coords
observeEvent(eventExpr = {input$global_filterBaseline | input$global_filterExplore | input$global_filterCustom}, {all=1:463
y=rep(1,length(all))
y[which(!(all %in% global_filter$r))]=0
in_global_filter$y=y
# cat(file=stderr(), 'global filter bin:', in_global_filter$y, "\n") # prints dimension to R console
# cat(file=stderr(), 'global filter:', global_filter$r, "\n") # prints dimension to R console
ranges$a=NULL
rangesExplore$a=NULL
rangesCustom$a=NULL}, priority =-1, ignoreNULL = TRUE, ignoreInit = TRUE)

```


For reference {data-orientation=columns}
=====================================

Column {.tabset .tabset-fade data-width=600}
-------------------------------------

### background information

```{r, background image}
include_graphics('https://i.imgur.com/EpuoFyr.png')

```

### robustness metrics

```{r, robustness metrics documentation}
tags$iframe(style="height:1000px; width:100%; scrolling=yes",
src="www/Robustness pdf for app.pdf")
```



Baseline performance {data-orientation=rows}
=====================================  

Column {.sidebar data-width=225}
------------------------------------

```{r, baseline UI}
h3('Local filters')
dropdownButton(circle=F, label='manual filters', width=190,
selectInput("VarBaseline1", label = "Filter 1:",
            choices = get_options('baseline'), selected = 'None'),
selectInput("IneqBaseline1", label = "Inequality 1:",
            choices = c('<', '>'), selected = '<'),
textInput('ThreshBaseline1', label= 'Threshold 1:', value='', placeholder='10'),

selectInput("VarBaseline2", label = "Filter 2:",
            choices = get_options('baseline'), selected = 'None'),
selectInput("IneqBaseline2", label = "Inequality 2:",
            choices = c('<', '>'), selected = '<'),
textInput('ThreshBaseline2', label= 'Threshold 2:', value='', placeholder='10'),

selectInput("VarBaseline3", label = "Filter 3:",
            choices = get_options('baseline'), selected = 'None'),
selectInput("IneqBaseline3", label = "Inequality 3:",
            choices = c('<', '>'), selected = '<'),
textInput('ThreshBaseline3', label= 'Threshold 3:', value='', placeholder='10'),

textInput("IDBaseline", label='Select policy IDs', placeholder='eg: 292,54')         
               
               )

div(style="margin-bottom:20px") # adds padding between buttons
actionButton('manualfilterBaseline',label='save manual filters', width=190)
div(style="margin-bottom:5px") # adds padding between buttons
actionButton('brushfilterBaseline',label='save brush filters', width=190)
div(style="margin-bottom:5px") # adds padding between buttons
actionButton('tablefilterBaseline',label='save table selections', width=190)
div(style="margin-bottom:5px") # adds padding between buttons
actionButton('localresetBaseline',label='reset local filters', width=190)
div(style="margin-bottom:20px") # adds padding between buttons

h3('Global filters')
actionButton('global_filterBaseline', label='save filters globally', width=190)
div(style="margin-bottom:5px") # adds padding between buttons
actionButton('resetBaseline',label='reset global filters', width=190)


h3('Plot options')
selectInput('colorBaseline', label='ParCoords color variable', choices=c(get_options('baseline'),'global.filter'), selected = 'Mead.1000', width=190)

selectInput('xAxisBaseline', label = 'Metric for ranking', choices=get_options('baseline')[-1], selected='Mead.1000', width=190)

div(style="margin-bottom:20px") # adds padding between buttons

downloadButton("download_b",label="Download filtered policies", width=190)

downloadHandler(filename="baseline filtered policies.xlsx", content=function(file) {
  
  # remove empty rows in the log objects
  data=filterLog$global
  global=data[rowSums(is.na(data)) != ncol(data),]
  data=logBaseline$log
  local=data[rowSums(is.na(data)) != ncol(data),]

  data.list=list("policies"=select(filter.baseline(), -starts_with("X")), "global.filters"=global, "local.filters"=local)
  write.xlsx(data.list, file)

})

```


```{r, baseline process UI, include=FALSE}
#### initialize with all 463 policies
policiesIDBaseline=reactiveValues(r=1:nrow(wide_data))
manualIDBaseline=reactiveValues(r=1:nrow(wide_data))
interactiveIDBaseline=reactiveValues(r=1:nrow(wide_data))

logBaseline=reactiveValues(log=df.initialize)
#### update manualIDBaseline based on user input

observeEvent(input$manualfilterBaseline, {
  
  temp=manual_filters(ID_key='IDBaseline', unique_thresh_ID = 'Baseline',dataframe = baseline(), page="baseline") # returns list of ID and log
  manualIDBaseline$r=temp[[1]]
  
  logBaseline$log=rbind(logBaseline$log, temp[[2]])
  
}, ignoreInit = T, ignoreNULL = T)

#### update interactiveIDBaseline based on par coords brushing
ranges <- reactiveValues(a=list())

#### get ranges from brushing

observeEvent(eventExpr = event_data("plotly_restyle", source = "pcoords"),{
  temp=get_brush_ranges(source = "pcoords", prep_df = prep_baseline)
  if (is.na(temp)){
    # do nothing
  } else {
     ranges$a[[temp[[1]]]]=temp[[2]]
     
  }
})

#### get policies from brushing
observeEvent(input$brushfilterBaseline,{
  temp=get_brush_policyID(ranges=ranges$a, prep_df = prep_baseline, page="baseline") # returns list of policy IDs and log
  interactiveIDBaseline$r=temp[[1]]
  
  # update log
  
  logBaseline$log=rbind(logBaseline$log, temp[[2]])
})

### update policiesIDBaseline as intersection of global filter, manual filter, and interactive filter

observe({
  a=intersect(manualIDBaseline$r, interactiveIDBaseline$r)
  b=intersect(a, global_filter$r)
  
  policiesIDBaseline$r=b
}
)

observeEvent(input$tablefilterBaseline,{
  policiesIDBaseline$r=intersect(policiesIDBaseline$r, tableSelectBaseline$id)
  
  add_vec=c("baseline", "policy", "table select", NA, NA, paste(as.character(tableSelectBaseline$id), collapse=","))
  logBaseline$log=rbind(logBaseline$log, add_vec)
})


### establish filter.baseline

filter.baseline=reactive({ # because baseline() already accounts for global filter, filter.baseline is intersection of global and local POLICY ID filter only
  
  dplyr::filter(baseline(), policy %in% policiesIDBaseline$r)
  
})

### apply global filter

observeEvent(input$global_filterBaseline, {
  
  global_filter$r=intersect(global_filter$r, policiesIDBaseline$r)
  
  remaining=length(global_filter$r)
  showNotification(paste(remaining, 'policies remain in global filter', sep=' ' ), type='message', duration=7)
  
  #transfer local log to global log
  filterLog$global=rbind(filterLog$global, logBaseline$log)
  
})


### local reset button

observeEvent(input$localresetBaseline, {
  policiesIDBaseline$r=1:nrow(wide_data)
  manualIDBaseline$r=1:nrow(wide_data)
  interactiveIDBaseline$r=1:nrow(wide_data)
  tableSelectBaseline$id=NULL
  ranges$a=NULL
  logBaseline$log=df.initialize
})

  # also, if color changes, reset local filters

observeEvent(input$colorBaseline,{
  #   policiesIDBaseline$r=1:nrow(wide_data)
  # manualIDBaseline$r=1:nrow(wide_data)
  interactiveIDBaseline$r=1:nrow(wide_data)
  ranges$a=NULL
  
  rows=which(logBaseline$log$filter.type=="brush")
  logBaseline$log=logBaseline$log[-rows,]
  
})

```

Row {data-height=325}    
-------------------------------------
### baseline performance  

```{r, baseline par_coords}

# create 13 blank labels since par_coords function takes 13 variables
labelsBaseline=rep('fill',13)
labelsBaseline[1:9]=colnames(metrics_4app$baseline)


plotlyOutput("pc1")


output$pc1=renderPlotly({
  
  # input$baseline_data_rows_selected
  
  isTruthy(input$localresetBaseline) # adding this statement causes interactive filters to reset,
  # but for some reason no brushes following the reset work in save brush filters action button
  ranges$a=NULL
  p=par_coords(data=data.frame(baseline_all(),global.filter=in_global_filter$y), n_var=9, 
             color_var = input$colorBaseline, title='baseline performance', labels=labelsBaseline, source='pcoords', policy_ID = tableSelectBaseline$constraints)
  p=event_register(p,"plotly_restyle")
  p
  
})


```

Row {.tabset .tabset-fade data-height=275}    
-------------------------------------
    
### Rank of filtered policies for selected metric
    
```{r}
############# baseline DV plot

renderPlotly({

  input$resetBaseline

  DV_plot(metric=filter.baseline(), to_plot = filter.baseline()[["policy"]], preferred_direction = 'min',
          metric_label = input$xAxisBaseline)


})

```

### Table of filtered policies

```{r}
  output$baseline_data <- DT::renderDataTable({
    input$localresetBaseline
    select(filter.baseline(), -starts_with("X"))
  },options = list(scrollY="245px", scrollX="100px", pageLength=10), server = TRUE
)

DT::dataTableOutput("baseline_data")

tableSelectBaseline=reactiveValues(id=NULL)

table_log=reactiveValues()

observe({
  tableSelectBaseline$id=filter.baseline()[['policy']][input$baseline_data_rows_selected]
  a=tableSelectBaseline$id-0.25
  b=tableSelectBaseline$id+0.25
  tableSelectBaseline$constraints=matrix(c(a,b),ncol=2, byrow = FALSE)})



```



Metric exploration {data-orientation=rows}
==========================================

Column{.sidebar data-width=225}
-------------------------------

```{r, Exploration UI}

df_names=names(metrics_4app)
name=reactiveValues(n='satisficing')
observeEvent(input$active_tab,{
    name$n=df_names[input$active_tab+1]
    # cat(file=stderr(), 'name$n=', name$n, "\n") # prints page name to console for debugging
})


h3('Local filters')
dropdownButton(label='manual filters', circle = F, width = 190,
               
renderUI({
  req(name$n)
  selectInput("VarExplore1", label = "Filter 1:",
            choices = get_options(name$n), selected = 'None')
}),

renderUI({
    req(name$n)
    selectInput("IneqExplore1", label = "Inequality 1:",
            choices = c('<', '>'), selected = '<')
}),

renderUI({
  req(name$n)
  textInput('ThreshExplore1', label= 'Threshold 1:', value='', placeholder='10')

}),

renderUI({
  req(name$n)
  selectInput("VarExplore2", label = "Filter 2:",
            choices = get_options(name$n), selected = 'None')
}),

renderUI({
      req(name$n)
    selectInput("IneqExplore2", label = "Inequality 2:",
            choices = c('<', '>'), selected = '<')
  
}),

renderUI({
    req(name$n)
  textInput('ThreshExplore2', label= 'Threshold 2:', value='', placeholder='10')

}),

renderUI({
  req(name$n)
  selectInput("VarExplore3", label = "Filter 3:",
            choices = get_options(name$n), selected = 'None')
}),

renderUI({
      req(name$n)
    selectInput("IneqExplore3", label = "Inequality 3:",
            choices = c('<', '>'), selected = '<')
  
}),

renderUI({
    req(name$n)
  textInput('ThreshExplore3', label= 'Threshold 3:', value='', placeholder='10')

}),

renderUI({
  req(name$n)
  textInput("IDExplore", label='Select policy IDs', placeholder='eg: 292,54')
})

)


div(style="margin-bottom:20px") # adds padding between buttons
renderUI({
  req(name$n)
  actionButton('manualfilterExplore', 'save manual filters', width=190)
})

div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(name$n)
  actionButton('brushfilterExplore',label='save brush filters', width=190)

})
div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(name$n)
  actionButton('tablefilterExplore',label='save table selections', width=190)

})
div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(name$n)
  actionButton('localresetExplore',label='reset local filters', width=190)

})
div(style="margin-bottom:20px") # adds padding between buttons

h3("Global filters")
renderUI({
  req(name$n)
  actionButton('global_filterExplore', label='save filters globally', width=190)
})
div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(name$n)
  actionButton('resetExplore',label='reset global filters', width=190)
})

div(style="margin-bottom:5px") # adds padding between buttons


div(style="margin-bottom:5px") # adds padding between buttons

h3("Plot options")
renderUI({
  req(name$n)
  selectInput('colorExplore', label='ParCoords Col Var', choices=c(get_options(name$n)[-1], 'global.filter', 'front'), selected = get_options(name$n)[2], width=190)

})

renderUI({
  req(name$n)
  selectInput('xAxisExplore', label = 'Metric for ranking', choices=get_options(name$n)[-1], selected=get_options(name$n)[2], width=190)
})


downloadButton("download_Explore",label="Download filtered policies")


downloadHandler(filename="Exploration filtered policies.xlsx", content=function(file) {
  
    # remove empty rows in the log objects
  data=filterLog$global
  global=data[rowSums(is.na(data)) != ncol(data),]
  data=logExplore$log
  local=data[rowSums(is.na(data)) != ncol(data),]

  data.list=list("policies"=select(filter.Explore(), -starts_with("X")), "global.filters"=global, "local.filters"=local)
  write.xlsx(data.list, file)

})




```



<script>
 $("body").on("shown.bs.tab", "a[data-toggle='tab']", function(e){
    Shiny.setInputValue("active_page", window.location.href);
 })
</script>

<script>
 $("body").on("shown.bs.tab", "div[id='section-row-2']", function(e){
    Shiny.setInputValue("active_tab", $(e.target).parent().index());
 })
</script>



```{r, Exploration process tabs, include=FALSE}

# the above JavaScript code was taken originally from here:
# https://stackoverflow.com/questions/64306794/how-to-get-the-current-active-tab-in-a-flexdashboard-document-to-reactively-disp

# I created two versions of the script from stackoverflow to perform two tasks, each using the jquery on(events [,selector], handler) function differently. Both on() function calls look for user to click. Then, the selecter argument and handler argument differs

# The first script uses the selector 'a[data-toggle='tab']' and the handler saves the page url via window.location.href. This means whenever a tab is toggled, the url is saved to input$active_page. I use this to track when 'Metric exploration' page is active
# see here for window.location.href: https://www.w3schools.com/js/js_window_location.asp
# see here for on() function: https://api.jquery.com/on/


# The second script tracks the tab index of the active par-coords in Metric exploration page. To avoid the tab index changing when on other pages or when changing between DV plot and table, I use the selector "div[id='section-row-2']". I discovered that this selector is unique to the Metric exploraiton page and par_coords (top) row. The bottom row (DV plot and table) has id='section-row-3', so changes in the tabs there are not registered as an event. I figured this out by opening the .html console log then exploring through the elements tab. To reach the .html console log, right click on the app when opened in a browser then selcect 'Inspect'



# preallocate reactiveValues used to track which page and tab the user is on
page=reactiveValues(ID="for-reference")
tab=reactiveValues(ID=0)
# count=reactiveValues(c=0)

# get the name of the active page. ie, baseline, for reference, metric exploration
observeEvent(input$active_page, {
  extract=sub(".*/#section-", "", input$active_page) # obtain characters after /#section- in the html address
  page$ID=extract
  # cat(file=stderr(), 'page$ID=', page$ID, "\n") # prints page name to console for debugging
  # cat(file=stderr(), 'input$active_page=', input$active_page, "\n") # prints page name to console for debugging

})


Explore_all=reactiveValues(df=prep_satisficing)

observe({
  # Explore_all$df=NULL
  if (!isTruthy(input$active_tab)){
    Explore_all$df=prep_satisficing
  } else if (input$active_tab==0){
    Explore_all$df=prep_satisficing
  } else if (input$active_tab==1){
    Explore_all$df=prep_regret2
  } else if (input$active_tab==2){
    Explore_all$df=prep_percent_deviation
  } else if (input$active_tab==3){
    Explore_all$df=prep_Laplace
  } else if (input$active_tab==4){
    Explore_all$df=prep_Hurwicz
  } else if (input$active_tab==5){
    Explore_all$df=prep_mean_var
  } else if (input$active_tab==6) {
    Explore_all$df=prep_maximin
  } else {
    Explore_all$df=prep_satisficing
  }
})

Explore=reactiveValues(df=prep_satisficing)

observe({
  Explore$df=dplyr::filter(Explore_all$df, policy %in% global_filter$r)
})


```

```{r, process Exploration UI}


#### initialize with all 463 policies
policiesIDExplore=reactiveValues(r=1:nrow(wide_data))
manualIDExplore=reactiveValues(r=1:nrow(wide_data))
interactiveIDExplore=reactiveValues(r=1:nrow(wide_data))

logExplore=reactiveValues(log=df.initialize)

#### update manualIDExplore based on user input

observeEvent(input$manualfilterExplore, {
  temp=manual_filters(ID_key='IDExplore', unique_thresh_ID = 'Explore',dataframe = Explore$df, page=paste0("Explore.",name$n))
  manualIDExplore$r=temp[[1]]
  
  logExplore$log=rbind(logExplore$log, temp[[2]])
})

#### update interactiveIDExplore based on par coords brushing
rangesExplore <- reactiveValues(a=list())

#### get ranges from brushing

observeEvent(eventExpr = event_data("plotly_restyle", source = name$n),{

  temp=get_brush_ranges(source = name$n, prep_df = Explore_all$df)
    if (is.na(temp)){
    # do nothing
  } else {
     rangesExplore$a[[temp[[1]]]]=temp[[2]]
     
  }
  # cat(file=stderr(), 'trying to filter df:', name$n, "\n")
  # cat(file=stderr(), 'trying to filter metric:', temp[[1]], "\n")

})

#### get policies from brushing

observeEvent(input$brushfilterExplore,{

  temp=get_brush_policyID(ranges=rangesExplore$a, prep_df = Explore_all$df, page=paste0("Explore.",name$n))
  
  interactiveIDExplore$r=temp[[1]]
  
  # update log
  
  logExplore$log=rbind(logExplore$log, temp[[2]])
  
})


### update policiesIDExplore as intersection of global filter, manual filter, and interactive filter

observe({
  a=intersect(manualIDExplore$r, interactiveIDExplore$r)
  b=intersect(a, global_filter$r)
  policiesIDExplore$r=b
}
)

### update policies for selections from table
observeEvent(input$tablefilterExplore, {
  policiesIDExplore$r=intersect(policiesIDExplore$r, tableSelectExplore$id)
  
  add_vec=c(paste0("Explore.", name$n), "policy", "table select", NA, NA, paste(as.character(tableSelectExplore$id), collapse=","))
  logExplore$log=rbind(logExplore$log, add_vec)
  
})

### establish filter.Explore

filter.Explore=reactive({ # because Explore$df already accounts for global filter, filter.Explore is intersection of global and local POLICY ID filter only

  dplyr::filter(Explore$df, policy %in% policiesIDExplore$r)

})

### apply global filter

observeEvent(input$global_filterExplore, {
  global_filter$r=intersect(global_filter$r, policiesIDExplore$r)
  
  remaining=length(global_filter$r)
  showNotification(paste(remaining, 'policies remain in global filter', sep=' ' ), type='message', duration=7)
  
  filterLog$global=rbind(filterLog$global, logExplore$log)
})


### local reset button

observeEvent(input$localresetExplore, {
  policiesIDExplore$r=1:nrow(wide_data)
  manualIDExplore$r=1:nrow(wide_data)
  interactiveIDExplore$r=1:nrow(wide_data)
  tableSelectExplore$id=NULL
  rangesExplore$a=NULL
  logExplore$log=df.initialize
})

  # also, if color changes, reset local filters

observeEvent(input$colorExplore,{
  #   policiesIDExplore$r=1:nrow(wide_data)
  # manualIDExplore$r=1:nrow(wide_data)
  interactiveIDExplore$r=1:nrow(wide_data)
  rangesExplore$a=NULL
  
  rows=which(logExplore$log$filter.type=="brush")
  logExplore$log=logExplore$log[-rows,]
  
})


```


Row {.tabset .tabset-fade data-height=325}
-------------------------------------------

### Satisficing-related
```{r, satisficing par coords}
# create 13 blank labels since par_coords function takes 13 variables
labelsSatisficing=rep('fill',13)
labelsSatisficing[1:8]=colnames(metrics_4app$satisficing)


plotlyOutput("pcSatisficing")


output$pcSatisficing=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,
  # but for some reason no brushes following the reset work in save brush filters action button
  rangesExplore$a=NULL
  p=par_coords(data=data.frame(Explore_all$df, global.filter=in_global_filter$y), n_var=8, 
             color_var = input$colorExplore, title='Satisficing-related metrics', labels=labelsSatisficing, max_cols = 2:4, source='satisficing', policy_ID = tableSelectExplore$constraints)
  p=event_register(p,"plotly_restyle")
  p
  
})


```

### Regret from best
```{r, par coords regret from best}

# create 13 blank labels since par_coords function takes 13 variables
labelsregret.from.best=rep('fill',13)
labelsregret.from.best[1:10]=colnames(metrics_4app$regret.from.best)


plotlyOutput("pcRegret.From.Best")


output$pcRegret.From.Best=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,
  # but for some reason no brushes following the reset work in save brush filters action button
  rangesExplore$a=NULL
  p=par_coords(data=data.frame(Explore_all$df, global.filter=in_global_filter$y), n_var=10, 
             color_var = input$colorExplore, title='Regret from best', labels=labelsregret.from.best, source='regret.from.best', policy_ID = tableSelectExplore$constraints)
  p=event_register(p,"plotly_restyle")
  p
  
})

```

### Percent deviation
```{r, par coords percent deviation}

# create 13 blank labels since par_coords function takes 13 variables
labelsPercent.Deviation=rep('fill',13)
labelsPercent.Deviation[1:10]=colnames(metrics_4app$percent.deviation)

plotlyOutput("pcPercent.Deviation")


output$pcPercent.Deviation=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,
  # but for some reason no brushes following the reset work in save brush filters action button
  rangesExplore$a=NULL
  p=par_coords(data=data.frame(Explore_all$df, global.filter=in_global_filter$y), n_var=10, 
             color_var = input$colorExplore, title='Percent deviation from baseline', labels=labelsPercent.Deviation, source='percent.deviation', policy_ID = tableSelectExplore$constraints)
  p=event_register(p,"plotly_restyle")
  p
  
})

```

### Laplace's PIR
```{r, par coords Laplaces PIR}

# create 13 blank labels since par_coords function takes 13 variables
labelsLaplaces.PIR=rep('fill',13)
labelsLaplaces.PIR[1:10]=colnames(metrics_4app$Laplaces.PIR)


plotlyOutput("pcLaplaces.PIR")


output$pcLaplaces.PIR=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,
  # but for some reason no brushes following the reset work in save brush filters action button
  rangesExplore$a=NULL
  p=par_coords(data=data.frame(Explore_all$df, global.filter=in_global_filter$y), n_var=10, 
             color_var = input$colorExplore, title='Laplaces Principle of Insufficient Reason (mean)', labels=labelsLaplaces.PIR, source='Laplaces.PIR', policy_ID = tableSelectExplore$constraints)
  p=event_register(p,"plotly_restyle")
  p
  
})


```

### Hurwicz optimism-pessimism

```{r}

# create 13 blank labels since par_coords function takes 13 variables
labelsHurwicz.OP=rep('fill',13)
labelsHurwicz.OP[1:10]=colnames(metrics_4app$Hurwicz.OP)

plotlyOutput("pcHurwicz.OP")


output$pcHurwicz.OP=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,
  # but for some reason no brushes following the reset work in save brush filters action button
  rangesExplore$a=NULL
  p=par_coords(data=data.frame(Explore_all$df, global.filter=in_global_filter$y), n_var=10, 
             color_var = input$colorExplore, title='Hurwicz Optimism-Pessimism with equal weighting', labels=labelsHurwicz.OP, source='Hurwicz.OP', policy_ID = tableSelectExplore$constraints)
  p=event_register(p,"plotly_restyle")
  p
  
})


```

### Mean-variance

```{r, par coords mean variance}
# create 13 blank labels since par_coords function takes 13 variables
labelsmean.variance=rep('fill',13)
labelsmean.variance[1:10]=colnames(metrics_4app$mean.variance)


plotlyOutput("pcmean.variance")


output$pcmean.variance=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,
  # but for some reason no brushes following the reset work in save brush filters action button
  rangesExplore$a=NULL
  p=par_coords(data=data.frame(Explore_all$df, global.filter=in_global_filter$y), n_var=10, 
             color_var = input$colorExplore, title='mean-variance', labels=labelsmean.variance, source='mean.variance', policy_ID = tableSelectExplore$constraints)
  p=event_register(p,"plotly_restyle")
  p
  
})


```

### Maximin
```{r, par coords maximin}
# create 13 blank labels since par_coords function takes 13 variables
labelsmaximim=rep('fill',13)
labelsmaximim[1:10]=colnames(metrics_4app$maximin)


plotlyOutput("pcmaximin")


output$pcmaximin=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,
  # but for some reason no brushes following the reset work in save brush filters action button
  rangesExplore$a=NULL
  p=par_coords(data=data.frame(Explore_all$df, global.filter=in_global_filter$y), n_var=10, 
             color_var = input$colorExplore, title='maximin (worst case SOW)', labels=labelsmaximim, source='maximin', policy_ID = tableSelectExplore$constraints)
  p=event_register(p,"plotly_restyle")
  p
  
})


```

Row {.tabset .tabset-fade data-height=275}
------------------------------------------

### Rank of filtered policies for selected metric

```{r, Explore DV plot}

output$Explore_DV=renderPlotly({
  
  # check=dim(filter.Explore())
  # cat(file=stderr(), 'dim=', check, "\n") # prints dimension to R console
  # check=input$xAxisExplore
  # cat(file=stderr(), 'x axis=', check, "\n") # prints dimension to R console

  
  req(isTruthy(input$xAxisExplore)) # removes temporary error message caused by input$xAxisCustom not rendering until input$apply
  req(input$xAxisExplore %in% colnames(filter.Explore()))
  
  
  if(startsWith(input$xAxisExplore, 'satisficing')){
    max_or_min='max'
  } else {
    max_or_min='min'
  }
  
  req(isTruthy(filter.Explore()))
  req(nrow(filter.Explore())>0)

  # check=colnames(filter.Explore())
  # cat(file=stderr(), 'cols=', check, "\n") # prints dimension to R console
  # check=min_or_max_Explore$a
  # cat(file=stderr(), 'min or max =', check, "\n") # prints dimension to R console
  
  DV_plot(metric=filter.Explore(), to_plot = filter.Explore()[["policy"]], preferred_direction = max_or_min,
          metric_label = input$xAxisExplore)
  
})

outputOptions(output, name='Explore_DV', priority=-100)
  
plotlyOutput('Explore_DV')

```

### Table of filtered policies

```{r, explore table}

output$Explore_data <- DT::renderDataTable({
  select(filter.Explore(), -starts_with("X"))
}, options = list(scrollY="245px", scrollX="100px", pageLength=10)
)

DT::dataTableOutput("Explore_data")

tableSelectExplore=reactiveValues(id=NULL)

observe({
  tableSelectExplore$id=filter.Explore()[['policy']][input$Explore_data_rows_selected]
  a=tableSelectExplore$id-0.25
  b=tableSelectExplore$id+0.25
  tableSelectExplore$constraints=matrix(c(a,b),ncol=2, byrow = FALSE)})


```




Select your own{data-orientation=rows}
=======================================

Column{.sidebar data-width=225}
--------------------------------


```{r, custom UI}

metric_types=c("",names(metrics_4app)) # add a blank element to beginning. This becomes default, and can be used to fail req()

# metric selection drop down
h3('Select dimensions')
dropdownButton(
               
  selectInput("type1", label = "metric 1 type:",
            choices = metric_types),
renderUI({
  req(input$type1)
  selectInput('metric1', 'metric 1:', choices=colnames(metrics.list[[input$type1]])[-1])
}),

#2
renderUI({
  req(input$metric1)
  selectInput("type2", label = "metric 2 type:",
            choices = metric_types)
}),

renderUI({
  req(input$type2)
  selectInput('metric2', 'metric 2:', choices=colnames(metrics.list[[input$type2]])[-1])
}),

#3

renderUI({
  req(input$metric2)
  selectInput("type3", label = "metric 3 type:",
            choices = metric_types)
}),

renderUI({
  req(input$type3)
  selectInput('metric3', 'metric 3:', choices=colnames(metrics.list[[input$type3]])[-1])
}),

#4

renderUI({
  req(input$metric3)
  selectInput("type4", label = "metric 4 type:",
            choices = metric_types)
}),

renderUI({
  req(input$type4)
  selectInput('metric4', 'metric 4:', choices=colnames(metrics.list[[input$type4]])[-1])
}),

#5

renderUI({
  req(input$metric4)
  selectInput("type5", label = "metric 5 type:",
            choices = metric_types)
}),

renderUI({
  req(input$type5)
  selectInput('metric5', 'metric 5:', choices=colnames(metrics.list[[input$type5]])[-1])
}),

# 6

renderUI({
  req(input$metric5)
  selectInput("type6", label = "metric 6 type:",
            choices = metric_types)  
}),

renderUI({
  req(input$type6)
  selectInput('metric6', 'metric 6:', choices=colnames(metrics.list[[input$type6]])[-1])
}),

#7 
renderUI({
  req(input$metric6)
  selectInput("type7", label = "metric 7 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type7)
  selectInput('metric7', 'metric 7:', choices=colnames(metrics.list[[input$type7]])[-1])
}),

#8
renderUI({
  req(input$metric7)
  selectInput("type8", label = "metric 8 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type8)
  selectInput('metric8', 'metric 8:', choices=colnames(metrics.list[[input$type8]])[-1])
}),
#9
renderUI({
  req(input$metric8)
  selectInput("type9", label = "metric 9 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type9)
  selectInput('metric9', 'metric 9:', choices=colnames(metrics.list[[input$type9]])[-1])
}),

#10
renderUI({
  req(input$metric9)
  selectInput("type10", label = "metric 10 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type10)
  selectInput('metric10', 'metric 10:', choices=colnames(metrics.list[[input$type10]])[-1])
}),
#11
renderUI({
  req(input$metric10)
  selectInput("type11", label = "metric 11 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type11)
  selectInput('metric11', 'metric 11:', choices=colnames(metrics.list[[input$type11]])[-1])
}),

#12
renderUI({
  req(input$metric11)
  selectInput("type12", label = "metric 12 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type12)
  selectInput('metric12', 'metric 12:', choices=colnames(metrics.list[[input$type12]])[-1])
}),

#13 REMOVE 13 because I need a policy row
# renderUI({
#   req(input$metric12)
#   selectInput("type13", label = "metric 13 type:",
#             choices = metric_types)  
# }),
# renderUI({
#   req(input$type13)
#   selectInput('metric13', 'metric 13:', choices=colnames(metrics.list[[input$type13]]))
# }),

actionButton('apply', 'apply selected metrics'),

# tooltip=tooltipOptions(title='Click to select metrics'),

width=190, label='select metrics', circle = F
  
  
)

div(style="margin-bottom:5px") # adds padding between buttons


############# filter selection dropdown

custom_options=reactive({
  cols=colnames(prep_custom.df()) # -1 to remove policy as option
  cols=cols[which(startsWith(cols, pattern='X')==FALSE)]
  all=c('None', cols)
  all
  })

h3('Local filters')
dropdownButton(label='manual filters', circle = F, width = 190,
               
renderUI({
  req(input$apply)
  selectInput("VarCustom1", label = "Filter 1:",
            choices = custom_options(), selected = 'None')
}),

renderUI({
    req(input$apply)
    selectInput("IneqCustom1", label = "Inequality 1:",
            choices = c('<', '>'), selected = '<')
}),

renderUI({
  req(input$apply)
  textInput('ThreshCustom1', label= 'Threshold 1:', value='', placeholder='10')

}),

renderUI({
  req(input$apply)
  selectInput("VarCustom2", label = "Filter 2:",
            choices = custom_options(), selected = 'None')
}),

renderUI({
      req(input$apply)
    selectInput("IneqCustom2", label = "Inequality 2:",
            choices = c('<', '>'), selected = '<')
  
}),

renderUI({
    req(input$apply)
  textInput('ThreshCustom2', label= 'Threshold 2:', value='', placeholder='10')

}),

renderUI({
  req(input$apply)
  selectInput("VarCustom3", label = "Filter 3:",
            choices = custom_options(), selected = 'None')
}),

renderUI({
      req(input$apply)
    selectInput("IneqCustom3", label = "Inequality 3:",
            choices = c('<', '>'), selected = '<')
  
}),

renderUI({
    req(input$apply)
  textInput('ThreshCustom3', label= 'Threshold 3:', value='', placeholder='10')

}),

renderUI({
  req(input$apply)
  textInput("IDCustom", label='Select policy IDs', placeholder='eg: 292,54')
})

)


div(style="margin-bottom:20px") # adds padding between buttons
renderUI({
  req(input$apply)
  actionButton('manualfilterCustom', 'save manual filters', width = 190)
})

div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(input$apply)
  actionButton('brushfilterCustom',label='save brush filters', width = 190)

})
div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(input$apply)
  actionButton('tablefilterCustom',label='save table selections', width = 190)

})
div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(input$apply)
  actionButton('localresetCustom',label='reset local filters', width = 190)

})
div(style="margin-bottom:20px") # adds padding between buttons

h3('Global filters')

renderUI({
  req(input$apply)
  actionButton('global_filterCustom', label='save filters globally', width = 190)
})
div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(input$apply)
  actionButton('resetCustom',label='reset global filters', width = 190)
})

div(style="margin-bottom:5px") # adds padding between buttons

h3('Plot options')

renderUI({
  req(input$apply)
  actionButton('addFront', label='Calculate fronts', width = 190)
})

div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(input$apply)
  selectInput('colorCustom', label='ParCoords Col Var', choices=c(custom_options()[-1], 'global.filter', 'front'), selected = custom_options()[1], width = 190)

})

renderUI({
  req(input$apply)
  selectInput('xAxisCustom', label = 'Metric for ranking', choices=custom_options()[-1], selected=custom_options()[1], width = 190)
})


downloadButton("download_Custom",label="Download filtered policies")


downloadHandler(filename="Custom filtered policies.xlsx", content=function(file) {

  # remove empty rows in the log objects
  data=filterLog$global
  global=data[rowSums(is.na(data)) != ncol(data),]
  data=logCustom$log
  local=data[rowSums(is.na(data)) != ncol(data),]

  data.list=list("policies"=select(filter.Custom(), -starts_with("X")), "global.filters"=global, "local.filters"=local)
  write.xlsx(data.list, file)
  
})



```


```{r, process Custom UI, include=FALSE}

# create custom dataframe
prep_custom.df=eventReactive(eventExpr={input$apply| input$addFront},{
  
  df=data.frame(matrix(nrow=nrow(wide_data), ncol=14)) # I added one exta column so there is always a NA row
  df=data.frame(df, add_to_tradeoff)
  df[,1]=wide_data$policy
  colnames(df)[1]='policy'
  for(i in 2:13){
    
    if (isTruthy(input[[paste0('metric',(i-1))]])){ # have to check if input was given. If not, error!
        
        type=input[[paste0('type',(i-1))]] # metric type (ie, regret2, LaplacePIR)
        name=input[[paste0('metric',(i-1))]] # metric name
        df[,i]=metrics.list[[type]][[name]]
        # df[,i]=metrics.list[[input[[paste0('type',(i-1))]]]][[input[[paste0('metric',(i-1))]]]]

        if (name %in% colnames(df)){ # check if column name alread exists
          colnames(df)[i]=paste(type,'.',name, sep='')
          first_i=which(colnames(df) == name)
          colnames(df)[first_i]=paste(input[[paste0('type',first_i-1)]], '.', name, sep='')
        } else {
          colnames(df)[i]=paste(type,'.',name, sep = '')
          # colnames(df)[i]=input[[paste0('metric',(i-1))]]
        }
          
    }
    

  }
  df
})


custom.df=reactive({dplyr::filter(prep_custom.df(), policy %in% global_filter$r)})

#### initialize with all 463 policies
policiesIDCustom=reactiveValues(r=1:nrow(wide_data))
manualIDCustom=reactiveValues(r=1:nrow(wide_data))
interactiveIDCustom=reactiveValues(r=1:nrow(wide_data))

logCustom=reactiveValues(log=df.initialize)

#### calculate non dominated front on user input ####

front.Custom=reactiveValues(f=rep(1,nrow(wide_data))) # initialize as ones

observeEvent(input$addFront,{
  
  withProgress(message='Calculating fronts', value=0, {
      front.Custom$f=calc_NonDom_front(data=prep_custom.df()[,1:nvar()], max_cols = max_id())
      incProgress(amount=0.75)
  })
  
}, priority = 100)


#### update manualIDCustom based on user input

observeEvent(input$manualfilterCustom, {
  temp=manual_filters(ID_key='IDCustom', unique_thresh_ID = 'Custom',dataframe = custom.df(), page="Custom")
  manualIDCustom$r=temp[[1]]
  
  logCustom$log=rbind(logCustom$log, temp[[2]])
})

#### update interactiveIDCustom based on par coords brushing
rangesCustom <- reactiveValues(a=list())
#### get ranges from brushing

observeEvent(eventExpr = event_data("plotly_restyle", source = "pcoordsCustom"),{

  df=data.frame(prep_custom.df()[,1:nvar()],front=front.Custom$f)

  temp=get_brush_ranges(source = "pcoordsCustom", prep_df = df)
    if (is.na(temp)){
    # do nothing
  } else {
     rangesCustom$a[[temp[[1]]]]=temp[[2]]
     
  }
  
})

#### get policies from brushing
observeEvent(input$brushfilterCustom,{

  
  df=data.frame(prep_custom.df()[,1:nvar()],front=front.Custom$f)

  temp=get_brush_policyID(ranges=rangesCustom$a, prep_df = df, page="Custom")
  
  interactiveIDCustom$r=temp[[1]]
   
  logCustom$log=rbind(logCustom$log, temp[[2]])
})

### update policiesIDCustom as intersection of global filter, manual filter, and interactive filter

observe({
  a=intersect(manualIDCustom$r, interactiveIDCustom$r)
  b=intersect(a, global_filter$r)
  policiesIDCustom$r=b
}
)

### update policiesIDCustom based on table selections

observeEvent(input$tablefilterCustom,{
  policiesIDCustom$r=intersect(policiesIDCustom$r, tableSelectCustom$id)
  
  add_vec=c("Custom", "policy", "table select", NA, NA, paste(as.character(tableSelectCustom$id), collapse=","))
  logCustom$log=rbind(logCustom$log, add_vec)
})

### establish filter.custom

filter.Custom=reactive({ # because Custom() already accounts for global filter, filter.Custom is intersection of global and local POLICY ID filter only
  validate(need(input$apply, 'Select robustness metrics'))
  dplyr::filter(custom.df(), policy %in% policiesIDCustom$r)
  
})

### apply global filter

observeEvent(input$global_filterCustom, {
  global_filter$r=intersect(global_filter$r, policiesIDCustom$r)
  
  remaining=length(global_filter$r)
  showNotification(paste(remaining, 'policies remain in global filter', sep=' ' ), type='message', duration=7)
  
  filterLog$global=rbind(filterLog$global, logCustom$log)
})


### local reset button

observeEvent(input$localresetCustom, {
  policiesIDCustom$r=1:nrow(wide_data)
  manualIDCustom$r=1:nrow(wide_data)
  interactiveIDCustom$r=1:nrow(wide_data)
  tableSelectCustom$id=NULL
  rangesCustom$a=NULL
  logCustom$log=df.initialize
})

# also, if color changes, reset local filters

observeEvent(input$colorCustom,{
  #   policiesIDCustom$r=1:nrow(wide_data)
  # manualIDCustom$r=1:nrow(wide_data)
  interactiveIDCustom$r=1:nrow(wide_data)
  rangesCustom$a=NULL
  
  rows=which(logCustom$log$filter.type=="brush")
  logCustom$log=logCustom$log[-rows,]
})



```

Row {data-height=325}
-----------------------
### Parallel coordinates

```{r, custom parallel coordinates}

nvar=reactive({
  test_vec=prep_custom.df()[1,] # obtain first row
  which(is.na(test_vec)==TRUE)[1]-1 # first entry with NA is index + 1 of final variable column
})

max_id=reactive({
  which(startsWith(colnames(prep_custom.df()), 'satisficing.satisficing')==TRUE)
})


plotlyOutput("pcCustom")

color_custom=reactiveValues() #initiate container for custom color variables initiation

output$pcCustom=renderPlotly({
  
  validate(need(input$apply, 'Select robustness metrics'))

  isTruthy(input$localresetCustom)
  rangesCustom$a=NULL

  # silent error occurs if I don't provide a default value for color_var. This happens because ParCoords Col Var hasn't initiated until filter policies is opened
  
  if (isTruthy(input$colorCustom)){
    color_custom$c=input$colorCustom
  } else {
    color_custom$c="policy"
  }
  

  if (isTruthy(input$addFront)){
    
          custom=par_coords(data=data.frame(prep_custom.df()[,1:nvar()],front=front.Custom$f, prep_custom.df()[,(nvar()+1):ncol(prep_custom.df())] ,global.filter=in_global_filter$y), n_var=nvar()+1, color_var = color_custom$c, title='user selected metrics', max_cols = max_id(),
             source='pcoordsCustom', policy_ID = tableSelectCustom$constraints)


  } else {
    custom=par_coords(data=data.frame(prep_custom.df(),global.filter=in_global_filter$y), n_var=nvar(), color_var = color_custom$c, title='user selected metrics', max_cols = max_id(),
             source='pcoordsCustom', policy_ID = tableSelectCustom$constraints)
  }
  

  custom=event_register(custom, "plotly_restyle")
  custom
  
})

```

Row {.tabset .tabset-fade data-height=275}
-------------------------------------------

### Rank of filtered policies for selected metric

```{r, Custom DV plot}

min_or_max_cust=reactive({
  
  if (startsWith(input$xAxisCustom, 'satisficing.satisficing')){
    'max'
  }else {
    'min'
  }
  
})

renderPlotly({
  req(input$xAxisCustom) # removes temporary error message caused by input$xAxisCustom not rendering until input$apply
  
  DV_plot(metric=filter.Custom(), to_plot = filter.Custom()[["policy"]], preferred_direction = min_or_max_cust(),
          metric_label = input$xAxisCustom)
  
})
  

```

### Table of filtered policies

```{r, Custom table}

output$Custom_data <- DT::renderDataTable({
  input$localresetCustom
  select(filter.Custom(), -starts_with("X"))
}, options = list(scrollY="245px", scrollX="100px", pageLength=10)
)

DT::dataTableOutput("Custom_data")

tableSelectCustom=reactiveValues(id=NULL)

observe({
  tableSelectCustom$id=filter.Custom()[['policy']][input$Custom_data_rows_selected]
  a=tableSelectCustom$id-0.25
  b=tableSelectCustom$id+0.25
  tableSelectCustom$constraints=matrix(c(a,b),ncol=2, byrow = FALSE)})

```

settings {.hidden}
=====================================

Column {.sidebar data-width=225}
------------------------------------

```{r}
# see color options here: https://plotly.com/r/reference/#parcoords

h4('Par Coords color scale')
selectInput("ColorScale", label=NULL, selected='blue-red', choices=c('blue-red', 'Viridis','Picnic', 'Rainbow', 'Portland', 'Blackbody', 'Cividis', "YlGnBu", "Jet", "Hot", "Earth"))

h4('Reverse color scale?')
switchInput("ReverseTF", onLabel='Yes', offLabel='No', value=FALSE, width = '100%')

```




